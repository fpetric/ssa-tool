#+Title: SSA-Tool: Working with Self-Stabilizing Algorithms
#+Author: Sean Allred

[[https://travis-ci.org/vermiculus/ssa-tool][https://travis-ci.org/vermiculus/ssa-tool.svg]]

This is a set of tools for the representation, creation, and
evaluation of self-stabilizing algorithms.

* Introduction
A self-stabilizing network is seen as a graph of state machines.  Each
privilege is realized as a transition from the current state to
another state.  The state of the graph is passed as input to this
state machine.  When the input graph matches some predicate, this
privilege is set -- there is some transition out of this state.  This
is why the choice of predicate to act upon is arbitrary: you can only
move to one other state!

When every node of the graph is in an accepting state with no set
predicates, then the graph has stabilized.

** Privilege
- We consider graphs of finite state machines.
- Privileges are boolean functions of the FSM's state and the states
  of its neighbors.
- When these functions are true, the privilege is 'present'.

** System State
- Each legitimate state must have at least one privilege present, even
  if the action is 'do nothing'
- In each legitimate state, every possible action will maintain
  legitimacy.
- Each privilege must be present in at least one legitimate state.
- For any given pair of legitimate states, there exists a
  transformation between them.

** Self-Stabilization
Regardless of the initial state and regardless of the privilege
selected each time for the next move, at least one privilege will
always be present and the system is guaranteed to find itself in a
legitimate state after a finite number of moves.

** References
- Edsger W. Dijkstra. 1974. Self-stabilizing systems in spite of
  distributed control. Commun. ACM 17, 11 (November 1974),
  643-644. DOI=http://dx.doi.org/10.1145/361179.361202

* Examples
#+BEGIN_SRC sh
  # move predefined code to the bundle
  python3 ssa.py test.ssax new predicate examples/ind-set.ssax/predicates/unmarked-and-neighbors-unmarked.py
  python3 ssa.py test.ssax new move examples/ind-set.ssax/moves/mark.py

  python3 ssa.py test.ssax new predicate examples/ind-set.ssax/predicates/marked-and-neighbor-marked.py
  python3 ssa.py test.ssax new move examples/ind-set.ssax/moves/unmark.py

  # create a new algorithm
  python3 ssa.py test.ssax new algorithm 'Independent Set'

  # define rules for that algorithm
  python3 ssa.py test.ssax add-rule-to 'Independent Set' unmarked-and-neighbors-unmarked.py mark.py
  python3 ssa.py test.ssax add-rule-to 'Independent Set' marked-and-neighbor-marked.py unmark.py

  # run the algorithm
  python3 ssa.py test.ssax run 'Independent Set'
#+END_SRC

Soon, =run= will be able to read graphs from a file.  For now, it
generates a grid graph.

After the CLI is featured enough to support it, a graphical interface
is planned to manage bundles and run algorithms -- showing the
evolution of a graph that can be explored or exported.

* Installing
This package can be installed locally using =pip install .=.  Be sure to
install the requirements with =pip install -r requirements.txt=.

Alternatively, use the targets from the Makefile: =make dependencies
install=.
