#+Title: SSA-Tool: Working with Self-Stabilizing Algorithms in Python
#+Author: Sean Allred
#+Date: [2014-03-11 Tue]

#+PROPERTY: noweb tangle
#+PROPERTY: mkdirp no

#+TODO: TODO INPROGRESS WRITE_TESTS WISH_LIST | DONE

[[https://travis-ci.org/vermiculus/ssa-tool][https://travis-ci.org/vermiculus/ssa-tool.png?branch=master]]

This is a set of tools for the representation, creation, and
evaluation of self-stabilizing algorithms.

I will add more content here soon, but please do see the documentation
for the project in [[file:src/ssa.org][src/ssa.org]].  It is a [[http://www-cs-faculty.stanford.edu/~uno/lp.html][literate program]] written with
[[http://orgmode.org/worg/org-contrib/babel][Org-Babel]] using the [[http://www.gnu.org/s/emacs][Emacs]] text editor.


* Example
  :PROPERTIES:
  :ID:       5D06B26D-A0A4-4FA2-8A29-BEF32962BFA9
  :END:
#+BEGIN_SRC python :tangle example.py
  import ssa.simulation.generators.random_graph as random_graph
  import ssa.core.Algorithm as Algorithm
  
  G = random_graph(5, marked='bool(.25)')
  
  @predicate(author='Sean Allred', version='1.0')
  def node_should_unmark(node, neighborhood):
      """Rule 1
  
      "marked"(n) = 1 `land `exists v `in N(n) : "marked"(v) = 1
  
      Returns True if the node is marked where a neighbor is also
      marked.
  
      """
      return n['marked'] and any(map(lambda v: v['marked'], neighborhood))
  
  @predicate(author='Sean Allred', version='1.0')
  def node_should_mark(node, neighborhood):
      """Rule 2
  
      "marked"(n) = 0 `land `forall v `in N(n), "marked"(v) = 0
  
      Returns True if the node is not marked and its entire neighborhood
      is also unmarked.
  
      """
      return not n['marked'] and all(map(lambda v: not v['marked'], neighborhood))
  
  @move(author='Sean Allred', version='1.0')
  def mark_node(node, neighborhood):
      node['marked'] = True
      return node, neighborhood
  
  @move(author='Sean Allred', version='1.0')
  def unmark_node(node, neighborhood):
      node['marked'] = False
      return node, neighborhood
  
  ind_set = Algorithm({
      node_should_mark: [mark_node],
      node_should_unmark: [unmark_node]
  })
#+END_SRC

* Introduction
** Directory Structure
The project is set up as a [[http://learnpythonthehardway.org/book/ex46.html][traditional Python module]]:
#+BEGIN_EXAMPLE
  ssa-tool/
      setup.py
      ssa/
          __init__.py
          core/
              __init__.py
          creation/
              __init__.py
          simulation/
              __init__.py
      bin/
      docs/
      tests/
          __init__.py
          core_tests.py
          creation_tests.py
          simulation_tests.py
#+END_EXAMPLE
** Setup
   :PROPERTIES:
   :ID:       42439234-46EF-4E23-99E4-CFBDFFC3562E
   :END:
#+BEGIN_SRC python :tangle "setup.py"
  try:
      from setuptools import setup
  except ImportError:
      from distutils.core import setup
  
  config = {
      'description': 'A utility for the creation and evaluation of self-stabilizing algorithms',
      'author': 'Sean Allred',
      'url': 'http://github.com/vermiculus/ssa-tool',
      'download_url': 'http://github.com/vermiculus/ssa-tool',
      'author_email': 'seallred@smcm.edu',
      'version': '0.1',
      'install_requires': ['networkx'],
      'packages': ['ssa'],
      'scripts': [],
      'name': 'ssa',
  }
  
  setup(**config)
#+END_SRC
*** TODO Fix =python setup.py install= sequence
It's saying I need a couple files:
#+BEGIN_EXAMPLE
  core.py
  creation.py
  simulation.py
#+END_EXAMPLE
but what goes in them?  I opened up a [[http://stackoverflow.com/questions/21685430/when-running-setup-py-install-on-my-module-what-needs-to-be-in-submodule-p][question on StackOverflow]], but
I'm not hopeful about getting any responses.

* Notes
** Dijkstra 1974
A self-stabilizing network is seen as a graph of state machines.  Each
privilege is realized as a transition from the current state to
another state.  The state of the graph is passed as input to this
state machine.  When the input graph matches some predicate, this
privilege is set---there is some transition out of this state.  This
is why the choice of predicate to act upon is arbitrary: you can only
move to one other state!

When every node of the graph is in an accepting state with no set
predicates, then the graph has stabilized.

*** privilege
- we consider graphs of finite state machines
- privileges are boolean functions of the FSM's state and the states
  of its neighbors
- when these functions are true, the privilege is 'present'
*** system state
- each legitimate state must have at least one privilege present
  - even if the action is 'do nothing'
- in each legitimate state, every possible action will maintain
  legitimacy
- each privilege must be present in at least one legitimate state
- for any given pair of legitimate states, there exists a
  transformation between them
*** self-stabilization
regardless of the initial state and regardless of the privilege
selected each time for the next move, at least one privilege will
always be present and the system is guaranteed to find itself in a
legitimate state after a finite number of moves.
