#+Title: Working with Self-Stabilizing Algorithms in Python
#+Author: Sean Allred
#+Date: [2013-12-24 Tue]

#+PROPERTY: noweb tangle
#+PROPERTY: mkdirp yes

#+TODO: TODO INPROGRESS WRITE_TESTS WISH_LIST | DONE

* Notes
** Dijkstra 1974
A self-stabilizing network is seen as a graph of state machines.  Each
privilege is realized as a transition from the current state to
another state.  The state of the graph is passed as input to this
state machine.  When the input graph matches some predicate, this
privilege is set---there is some transition out of this state.  This
is why the choice of predicate to act upon is arbitrary: you can only
move to one other state!

When every node of the graph is in an accepting state with no set
predicates, then the graph has stabilized.

*** privilege
- we consider graphs of finite state machines
- privileges are boolean functions of the FSM's state and the states
  of its neighbors
- when these functions are true, the privilege is 'present'
*** system state
- each legitimate state must have at least one privilege present
  - even if the action is 'do nothing'
- in each legitimate state, every possible action will maintain
  legitimacy
- each privilege must be present in at least one legitimate state
- for any given pair of legitimate states, there exists a
  transformation between them
*** self-stabilization
regardless of the initial state and regardless of the privilege
selected each time for the next move, at least one privilege will
always be present and the system is guaranteed to find itself in a
legitimate state after a finite number of moves.


* Introduction
The project is set up as a [[http://learnpythonthehardway.org/book/ex46.html][traditional Python module]]:
#+BEGIN_EXAMPLE
  setup.py
  ssa/
      __init__.py
      core/
          __init__.py
      creation/
          __init__.py
      simulation/
          __init__.py
  bin/
  docs/
  tests/
      __init__.py
      core_tests.py
      creation_tests.py
      simulation_tests.py
#+END_EXAMPLE
#+BEGIN_SRC python :tangle "./setup.py"
  try:
      from setuptools import setup
  except ImportError:
      from distutils.core import setup
  
  config = {
      'description': 'A utility for the creation and evaluation of self-stabilizing algorithms',
      'author': 'Sean Allred',
      'url': 'http://github.com/vermiculus/smp',
      'download_url': 'http://github.com/vermiculus/smp',
      'author_email': 'seallred@smcm.edu',
      'version': '0.1',
      'install_requires': ['networkx', 'pygame'],
      'packages': ['ssa'],
      'scripts': [],
      'name': 'ssa'
  }
  
  setup(**config)
#+END_SRC
#+BEGIN_SRC python :tangle "ssa/__init__.py"
  import core
  import creation
  import simulation
#+END_SRC
* [#A] Core Classes
#+BEGIN_SRC python "ssa/core/__init__.py"
  
#+END_SRC
In Dijkstra's 1974 paper, he describes a self-stabilizing algorithm as
a graph of state-machines:
#+BEGIN_QUOTE
We consider a connected graph in which the majority of the possible
edges are missing and a finite state machine is placed at each node;
machines placed in directly connected nodes are called each other's
neighbors.  For each machine one or more so-called "privileges" are
defined, i.e. boolean functions of its own state and the states of its
neighbors; when such a boolean function is true, we say that the
privilege is "present."  In order to model the undefined speed ratios
of the various machines, we introduce a central daemon---its
replacement by a distributed daemon falls outside the scope of this
article---that can "select" one of the privileges present.  The
machine enjoying the selected privilege will then make its "move";
i.e. it is brought into a new state that is a function of its old
state and the states of its neighbors.  If for such a machine more
than one privilege is present, the new state may also depend on the
privilege selected.  After completion of the move, the daemon will
select a new privilege.
#+END_QUOTE
Thus, we need to create a new class to act as the nodes of a NetworkX
graph.  This new node class will impose a collection of privileges
upon the object---privilege functions that must be additionally given
the collection of its neighbors.  These privilege functions do, of
course, return =True= or =False=.

Here comes the fun part: the new node class has a property (or rather,
a function =privileges_present=, TODO "python property act like a
function") that returns the identifications of all privileges that are
active---all those privileges of the node that return =True=---and
these identifications are then linked by a mapping within the node to
actions that they apply to.

** DONE Dependencies
#+BEGIN_SRC python :tangle "ssa/core/__init__.py"
  from TeXableEntity import TeXableEntity
  from FiniteStateMachine import FiniteStateMachine
#+END_SRC
** DONE TeXable Entity
Since this is all math and this research uses TeX almost exclusively,
it is worthwhile to include auto-generation of TeX documentation for
the algorithm.

A =TeXableEntity= is an object that has both human-readable
documentation and a TeX representation.  The documentation is what is
returned when the object is interpreted as a string, and the TeX
representation is the first part of the returned tuple when the object
is asked for its own representation.
#+BEGIN_SRC python :tangle "ssa/core/TeXableEntity.py"
  class TeXableEntity:
      """A documented object
  
      TeXableEntity is a very simple base class for mathematics-based
      objects (such as FiniteStateMachine).  It is assumed that the
      first bit is pure mathematics (something to be placed inside an
      'align' environment).
  
      >>> t = TeXableEntity('x', 'The variable $x$')
      >>> t
      TeXableEntity(TeX='x', doc='The variable $x$')
  
      >>> t.TeX
      'x'
  
      >>> t.doc
      'The variable $x$'
  
      >>> eval(repr(t)) == t
      True
      """
      __initializer = 'TeXableEntity(TeX={TeX!r}, doc={doc!r})'
      def __init__(self, TeX=None, doc=None):
          self.TeX = TeX
          self.doc = doc
  
      def __repr__(self):
          return self.__initializer.format(**self.__dict__)
  
      def __str__(self):
          return str(self.doc)
      
      def __eq__(self, other):
          if isinstance(other, TeXableEntity):
              return self.TeX == other.TeX and self.doc == other.doc
          else:
              return False
  
  if __name__ == '__main__':
      import doctest
      doctest.testmod()
#+END_SRC
** INPROGRESS Finite State Machine
#+BEGIN_SRC python :tangle "ssa/core/FiniteStateMachine.py"
  from TeXableEntity import TeXableEntity
  
  class FiniteStateMachine(TeXableEntity):
      def __init__(self,
                   alphabet      = set(),
                   states        = set(),
                   initial_state = None,
                   accept_states = set(),
                   transitions   = dict()):
  
          self.accept_states = accept_states
          self.initial_state = initial_state
          self.states        = states
          self.alphabet      = alphabet
          self.transitions   = transitions
  
      <<machine editing>>
  
      <<machine functionality>>
#+END_SRC
*** INPROGRESS Machine Editing
:PROPERTIES:
:noweb-ref: "machine editing"
:noweb-sep: "\n\n"
:END:
**** WRITE_TESTS Transitions
Here we add logic supporting on-the-fly addition of transitions.  If
either the =source= or =destination= states are not in the set of
states, they will be added.

If the transition is already defined, a =KeyError= will be raised.
#+BEGIN_SRC python
  def add_transition(self, source, token, destination):
      """Adds a transition from source to destination on an input
      token.
  
      If such a transition is already defined, a KeyError will be
      raised.
      """
      self.states.add(source)
      self.states.add(destination)
  
      if source not in self.transitions:
          self.transitions[source] = dict()
      elif token in self.transitions[source]:
          raise KeyError('Input token already defined for source.')
  
      self.transitions[source][token] = destination
#+END_SRC

**** WRITE_TESTS Initial State
#+BEGIN_SRC python
  def set_initial_state(self, state):
      """Set the initial state for this machine.
  
      If the given state is not in the machine's set of states, it will
      be added.
      """
      self.states.add(state)
      self.initial_state = state
#+END_SRC

**** TODO Alphabet

**** TODO Accept States

*** TODO Machine Functionality
:PROPERTIES:
:noweb-ref: "machine functionality"
:noweb-sep: "\n\n"
:END:
**** WISH_LIST add an input buffer
It'd be cool to have an input buffer to push an entire sentence.  I
don't know how useful it would be in the current overall project, but
perhaps this could be made more robust and separated out into its own
module.
**** WRITE_TESTS Resetting the Machine
#+BEGIN_SRC python
    def reset(self):
        self.current_state = self.initial_state
#+END_SRC

**** WRITE_TESTS Receiving Input
#+BEGIN_SRC python
  def update(self, token):
      """Updates the state of the machine according to the input token.
  
      If the input token is not defined for the current state, an
      Exception is raised to signal failure.
      """
      if token in self.transition[self.current_state]:
          self.current_state = self.transition[self.current_state][token]
      else:
          raise Exception('The machine has rejected your input')
#+END_SRC
**** DONE Reporting State
You can grab the current state of the machine by looking at the value
of =FiniteStateMachine.current_state=.
***** WISH_LIST Perhaps unsafe.
** [#A] Privileges and Actions
Privileges and Actions are very similar to each other.
*** TODO TeX-enabled predicates/actions
Create a class for =Predicate= and =Action= that both inherit from
=TeXableEntity=.  We should be able to attach TeX documentation to
rules and predicates so that we can have a nice display of the entity.

This could also be useful in export.
*** Privileges
#+BEGIN_SRC python :tangle "ssa/core/Privilege.py"
  class Privilege(TeXableEntity):
      """A function from G, v -> {True, False}
  
      >>> pred = Privilege(lambda G, v: v in G,
                           'G, v \mapsto v \in G',
                           'Returns true when $v$ is a node in $G$')
      >>> doc(pred)
      'Returns true when $v$ is a node in $G$'
      >>> repr(pred)
      'G, v \mapsto v \in G'
      """
      def __init__(self, predicate = lambda graph, node: True,
                         as_TeX    = None,
                         doc       = None):
          TeXableEntity.__init__(self, as_TeX, doc)
          self.predicate = predicate
  
      def __call__(self, graph, node):
          return self.predicate(graph, node)
  
      def __bool__(self, graph, node):
          return self()
#+END_SRC
**** TODO doctest callable
requires making a graph... ugh
*** Actions
#+BEGIN_SRC python :tangle "ssa/core/Action.py"
  class Action(TeXableEntity):
      """A function from G, v -> G'
  
      >>> action = Action(lambda G, v: v['marked'] = True,
                          'v.marked \gets True',
                          'Marks $v$')
      >>> doc(action)
      'Mark $v$'
      >>> repr(action)
      'v.marked \gets True'
      """
      def __init__(self, action = lambda graph, node: graph,
                         as_TeX = None,
                         doc    = None):
          TeXableEntity.__init__(self, as_TeX, doc)
          self.action = action
  
      def __call__(self, graph, node):
          return self.action(graph, node)
#+END_SRC
**** TODO doctest callable
** [#A] Self-Stabilizing Algorithm
- a dictionary from =Rule= objects to sets of =Privilege= objects.
- also a =TeXableEntity=

old code
#+BEGIN_SRC python :tangle "ssa/core/SelfStabilizingAlgorithm.py"
  """
  Base class for self-stabilizing algorithms.
  """
  
  __author__ = "Sean Allred (seallred@smcm.edu)"
  
  import networkx as nx
  import random
  
  class SelfStabilizingAlgorithm:
      """Base class for self-stabilizing algorithms.
  
      The SelfStabilizingAlgorithm class represents its namesake as a set
      of predicate-action pairs.
      """
      def __init__(self, rules=dict()):
          self.rules = rules
  
          for predicates in rules.keys():
              if not hasattr(predicates, '__getitem__'):
                  predicates = [predicates]
              for p in predicates:
                  self.add_rule(predicate, rules[predicate])
  
      def add_rule(self, predicate=lambda graph, privileged_node: True,
                         action=lambda graph, privileged_node: graph):
          """Add a rule to this algorithm.
  
          Parameters
          ----------
          predicate : f: (graph, node) \to {True, False}
          action :    f: (graph, node) \to graph
          """
          if predicate in self.rules:
              self.rules[predicate].append(action)
          else:
              self.rules[predicate] = [action]
  
      def apply_to(graph, count=1, keep_history=False):
          """Apply this algorithm to `graph` `count` times.
  
          Algorithm
          ---------
          Initialize this history and the current graph.  For as many
          times specified by `count`, do the following:
  
             1. Create a set of nodes that we need to check in this round,
                initialized to the complete set of nodes currently in the
                graph.
             2. While we have nodes to check,
                2.1 Randomly choose a privileged node from the set of
                    unchecked nodes.
                2.2 Create a set of all predicates that apply to the              # TODO: unnecessary to check them all
                    privileged node.
           ,*    2.3 If this set is not empty, choose a random predicate
                    from that set.  Otherwise, break out of the while
                    loop, leaving the matching predicate as a None-value
                    (see step 3).
                2.4 Remove this node from the set of unchecked nodes
           ,* 3. If the matching predicate is None, break.  There is no
                point in continuing to check since the state of the
                graph will no longer change.
             4. Retrieve the approriate action for the matching
                predicate.
             5. Update the current graph by applying the action
                appropriately.
             6. If we are keeping history, record the necessary elements
                and update the current graph to a deep copy of itself.
  
          (*) Represents a step where program flow may be redirected.
  
          Returns
          -------
          If `keep_history` is specified, the function will return a
          history (as a list of 3-tuples) that map the current state of
          the graph to the predicate and node that caused it.
          """
          history = [(graph, None, None)]
  
          if keep_history:
              current_graph = graph.copy()
          else:
              current_graph = graph
  
          for i in range(count):
              unchecked_nodes = current_graph.get_nodes()[:]
  
              privileged_node = None
              matching_predicate = None
  
              while unchecked_nodes:
                  privileged_node = random.choice(unchecked_nodes)
  
                  # I'm not using shuffle because "Note that for even
                  # rather small len(x), the total number of
                  # permutations of x is larger than the period of most
                  # random number generators; this implies that most
                  # permutations of a long sequence can never be
                  # generated."
                  preds = [p for p in self.rules.keys()]
                  while preds:
                      matching_predicate = random.choice(preds)
  
                      if p(current_graph, privileged_node):
                          break
  
                      preds.remove(matching_predicate)
  
                  unchecked_nodes.remove(privileged_node)
  
              if matching_predicate is None: break
              else:
                  matching_action = random.choice(self.rules[matching_predicate])
                  current_graph = matching_action(current_graph,
                                                  privileged_node)
  
                  if keep_history:
                      history.append((current_graph,
                                      matching_predicate,
                                      privileged_node))
                      current_graph = current_graph.copy()
  
          if keep_history:
              return history
          else:
              return graph
#+END_SRC
* [#B] Creation
  A graphical tool for the creation of self-stabilizing algorithms
#+BEGIN_SRC python :tangle "ssa/creation/__init__.py"

#+END_SRC
* [#B] Simulation
#+BEGIN_SRC python :tangle "ssa/simulation/__init__.py"
import generators
from ColorBank import ColorBank
from BasicNode import BasicNode
#+END_SRC
** Displaying a Graph
*** Managing Colors
#+BEGIN_SRC python :tangle "ssa/simulation/ColorBank.py"
  class ColorBank:
      def __init__(self):
          self.black = (0, 0, 0)
          self.white = (255, 255, 255)
          self.red   = (255, 0, 0)
          self.green = (0, 255, 0)
          self.blue  = (0, 0, 255)
  
      def set_color(self, name, red, green, blue):
          setattr(self, str(name), (red, green, blue))
  
      @classmethod
      def get_inverse(cls, color, alpha=1):
          inverses = [255 - c for c in color] + [alpha]
          return tuple((channel for channel in inverses))
  
      @classmethod
      def random(cls, r):
          return tuple((r.randint(0, 255) for i in range(3)))
#+END_SRC
*** A Basic Node
#+BEGIN_SRC python :tangle "ssa/simulation/BasicNode.py"
  from ColorBank import ColorBank

  class BasicNode:
      default_radius = 25
      default_color = (0,0,0)
      default_data = None
      default_position = (0, 0)
  
      def __init__(self, position=None,
                         radius=None,
                         color=None,
                         data=None,
                         randomize=None):
          if randomize is not None:
              r=randomize
              if data         is None: data       = '(random)'
              if color        is None: color      = ColorBank.random(r)
              if radius       is None: radius     = r.randint(3,50)
              if position     is None: position   = (r.random(), r.random())
          else:
              if data         is None: data       = BasicNode.default_data
              if color        is None: color      = BasicNode.default_color
              if radius       is None: radius     = BasicNode.default_radius
              if position     is None: position   = BasicNode.default_position
  
          if any(map(lambda c: not (0 <= c <= 1), position)):
              raise Exception('Woah there buddy.')
  
          self.data       = data
          self.color      = color
          self.radius     = radius
          self.position   = position
      def __str__(self):
          return str(self.data)
      def __repr__(self):
          return str(self.__dict__)
#+END_SRC
*** Displaying the Game Window
#+BEGIN_SRC python :tangle "ssa/simulation/Visualizer.py"
  import pygame
  import networkx as nx
  
  from ColorBank import ColorBank
  from BasicNode import BasicNode
  
  class Visualizer:
      def __init__(self, size=(640, 480), graph=nx.Graph()):
          """where `size` is a 2-tuple representing screen dimens"""
  
          self.screen = pygame.display.set_mode(size)
  
          self.colors = ColorBank()
          self.graph = graph
          self.layout_algorithms = [getattr(nx, a) for a in dir(nx) if a.endswith('_layout')]
          # TODO sometimes crashes here; why?
          self.text_font = pygame.font.SysFont('monospace', 15)
  
      def do_layout(self, layout_algorithm=None):
          if layout_algorithm is None:
              layout_algorithm = self.layout_algorithms[0]
  
          try:
              p = layout_algorithm(self.graph)
          except:
              print 'Layout algorithm `{!s}` not yet supported.'.format(repr(layout_algorithm).split()[1])
              print 'Please install the appropriate package.'
              return
  
          for node, position in zip(p.keys(), p.values()): # in p isn't working: iteration over non-sequence
              node.position = ((position[0] + 1) / 2, (position[1] + 1) / 2)
  
      def draw(self):
          self.screen.fill(self.colors.green)
          size = self.screen.get_size()
  
          for src, dst in self.graph.edges():
              pygame.draw.line(self.screen, self.colors.white,
                               self.floats_to_pos(src.position),
                               self.floats_to_pos(dst.position), 3)
  
          for n in self.graph.nodes():
              normal_pos = self.floats_to_pos(n.position) # keep track of z order for drag drop
              pygame.draw.circle(self.screen, n.color, normal_pos, n.radius, 0)
              label = self.text_font.render(str(n.data), True, ColorBank.get_inverse(n.color))
              self.screen.blit(label, normal_pos)
  
          pygame.display.update()
  
      def floats_to_pos(self, floats):
          return tuple((int(coordinate * scale) for coordinate, scale in zip(floats, self.screen.get_size())))
  
      def pos_to_floats(self, position):
          return tuple((coordinate / scale for coordinate, scale in zip(position, self.screen.get_size())))
  
      def loop(self):
          ingame=True
          while ingame:
              self.draw()
              pygame.time.delay(500)
              self.do_layout()
              for event in pygame.event.get():
                  if event.type == pygame.QUIT:
                      pygame.quit()
                      ingame = False
  
  if __name__ == '__main__':
      pygame.init()
      screen_size = (640, 480)
  
      import generators
  
      g = generators.random_graph((5, 20), .3,
                                  data='(random)',
                                  color=lambda r: ColorBank.random(r),
                                  radius='int(3, 10)',
                                  position=lambda r: tuple([r.random(), r.random()]))
  
      vis = Visualizer(size=screen_size, graph=g)
      vis.do_layout()
  
      vis.loop()
#+END_SRC
** Generators
#+BEGIN_SRC python :tangle "ssa/simulation/generators.py"
  import networkx
  import random
  from itertools import combinations
  
  class BasicNode:
      def __init__(self):
          pass
      def __repr__(self):
          return '{}::{}'.format(id(self), self.__dict__)
  
  <<random graphs>>

  if __name__ == '__main__':
      import doctest
      doctest.testmod()
#+END_SRC
*** Generating a Random Graph
    :PROPERTIES:
    :noweb-ref: random graphs
    :END:
To thoroughly test graph algorithms (in lieu of or in preparation for
proof), it is very useful to have a means to create randomized graphs
with certain characteristics.  NetworkX has a few generators at its
disposal for creating graphs with deeper properties than I have
knowledge of, but the following function is able to create a random
graph with nodes having randomized properties.
#+BEGIN_SRC python
  def random_graph(degree, edge_probability=0.5, base_class=BasicNode, **properties):
      """Generates a random graph of `degree` nodes, a specified
      probability for edges, and a number of random properties.
      
      <<summary>>
  
      <<doctest basic usage>>
  
      <<doctest errors>>
      """
      r = random.Random()
      G = networkx.Graph()
  
      <<check if degree is range>>
  
      for n in range(degree):
          <<add node>>
  
      <<add edges>>
      
      return G
#+END_SRC
**** Documentation
***** Summary
    :PROPERTIES:
    :noweb-ref: summary
    :END:
#+BEGIN_SRC markdown
  If `degree` is a tuple, it is assumed to be a (min, max) tuple
  defining an inclusive range of possible degrees.
    
  Each `properties` value can be a function of a random number
  generator.  If the value does not have `__call__` defined, it will be
  assumed a string unless, as a string, it is one of the following:
    
  - 'int(n,m)' :: a random integer in [n, m]
  - 'float()'  :: a random floating point number in [0, 1)
  - 'bool(n)'  :: a random boolean with a probability of truth between 0
                  and 1 inclusive (where 1 is True).
    
  If the property value is neither callable nor a string of this form,
  then the value is simply set raw.
#+END_SRC
***** Basic Usage
    :PROPERTIES:
    :noweb-ref: doctest basic usage
    :END:
#+BEGIN_SRC markdown
  Pass in a single argument, the degree of the graph, to get the
  bare-minimum graph (with a certain edge probability):
    
      >>> G = random_graph(50)
      >>> len(G.nodes())
      50
  
  Pass in a tuple to get a range of values:
    
      >>> G = random_graph((40, 60))
      >>> len(G.nodes()) in range(40, 60 + 1)
      True
    
  You can also use a few intelligent arguments, such as bool(n):
    
      >>> all(map(lambda n: n.marked,
      ...         random_graph(10, marked='bool(1)')))
      True
      >>> any(map(lambda n: n.marked,
      ...         random_graph(10, marked='bool(0)')))
      False
    
  float():
    
      >>> .45 < sum(map(lambda n: n.weight,
      ...         random_graph(1000, weight='float()')))/1000 < .55
      True
    
  and int(min, max):
    
      >>> all(map(lambda n: n.age in range(40, 50 + 1),
      ...         random_graph(10, age='int(40, 50)')))
      True
#+END_SRC

***** Possible Errors
    :PROPERTIES:
    :noweb-ref: doctest errors
    :END:
#+BEGIN_SRC markdown
  Be careful about the arguments you pass.  If you want a range of
  possible values for the degree, ensure you pass an iterable of exactly
  two elements.
    
      >>> random_graph((1,2,3))
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      ValueError: Wrong number of values for (min, max) degree
    
  Mind the arguments for the keywords 'bool', 'int', and 'float'.
    
      >>> random_graph(5, marked='int(3,4,5)')
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      ValueError: Wrong number of arguments for int.
    
#+END_SRC
**** Code
***** Check Degree
     :PROPERTIES:
     :noweb-ref: check if degree is range
     :END:
#+BEGIN_SRC python
  if hasattr(degree, '__getitem__'):
      if len(degree) is not 2:
          raise ValueError('Wrong number of values for (min, max) degree')
      degree = r.randint(*degree)
#+END_SRC
***** Adding Nodes
     :PROPERTIES:
     :noweb-ref: add node
     :END:
#+BEGIN_SRC python
  new_node = base_class()
      
  for key in properties:
      new_prop = str(key)
      new_value = properties[key]
      
      <<check for property overwrite>>
      
      <<parse and set property value>>
    
  G.add_node(new_node)
#+END_SRC
****** Property Overwrite
     :PROPERTIES:
     :noweb-ref: check for property overwrite
     :END:
#+BEGIN_SRC python
  # Avoid overwriting properties.  This could happen if the
  # user passes in something that is a dictionary rather
  # than a traditional KV list.  We'll accept anything that
  # has __str__, but __str__ is not meant to be unique.
  if hasattr(new_node, new_prop): 
      raise Exception('Did not overwrite duplicate property')
#+END_SRC
****** Property Set
     :PROPERTIES:
     :noweb-ref: parse and set property value
     :END:
#+BEGIN_SRC python
  if hasattr(new_value, '__call__'):
      setattr(new_node, new_prop, new_value(r))
  else:
      if '(' in new_value and ')' in new_value: # val is a func
          # collect the arguments
          # TODO: make this safe, i.e. destroy `eval`
          func = new_value[:new_value.index('(')]
          args = eval(new_value[new_value.index('('):])
          ex = lambda t: ValueError('Wrong number of arguments for {}.'.format(t))
  
          if func == 'float':
              if len(args) is not 0: raise ex('float')
              new_value = r.random()
          elif func == 'int':
              if len(args) is not 2: raise ex('int')
              new_value = r.randint(*args)
          elif func == 'bool':
              new_value = r.random() <= float(args)
  
      setattr(new_node, new_prop, new_value)
#+END_SRC
***** Adding Edges
     :PROPERTIES:
     :noweb-ref: add edges
     :END:
#+BEGIN_SRC python
  for src, dst in combinations(G.nodes(), 2):
      # perhaps add switch to check for __call__(node_a, node_b)
      if r.random() <= edge_probability:
          G.add_edge(src, dst)
#+END_SRC
** [#B] On-screen animation
** [#C] Step-by-Step TeX printouts
* [#B] Tests
We will be using the Nose toolset for automated testing.
#+BEGIN_SRC python :noweb-ref "common imports for testing"
  import unittest
  from nose.tools import *
#+END_SRC
** Core
#+BEGIN_SRC python :tangle "tests/core_tests.py"

#+END_SRC
** Creation
#+BEGIN_SRC python :tangle "tests/creation_tests.py"

#+END_SRC
** Simulation
This test is structured as those above, with a few specializations.
Since the random graph generator does not (and should not) create
predictable or reproducible results, we must create a very large
random graph (1000 nodes) and then perform some analysis on that same
graph multiple times.  (Otherwise, the tests would hang on this
portion for some time.)

We import all those classes that we need to and define a testing class
to contain the random graph in the correct scope.  After we define a
few helper functions to look at only one attribute at a time, we then
make our assertions on what the results /should/ look like.
#+BEGIN_SRC python :tangle "tests/simulation_tests.py"
  <<common imports for testing>>

  from ssa.simulation import *
  
  class RandomGraphTest(unittest.TestCase):
      @classmethod
      def setupClass(cls):
          cls.G = \
          <<create random graph>>
  
      <<define helper functions>>
  
      <<test randomness>>
#+END_SRC

We create a random graph with the following properties:
- degree :: 1000
- edge probability :: 70%
- marked :: 30% chance of being marked
- answer :: equal chances of being 'yes', 'no', or 'maybe'
- weight :: a random real in [0, 1)
- age :: a random number between 18 and 65
#+BEGIN_SRC python :noweb-ref "create random graph"
  generators.random_graph(\
      1000, .7,
      marked='bool(.3)',
      answer=lambda r: r.choice(['yes', 'no', 'maybe']),
      weight='float()',
      age='int(18, 65)')
#+END_SRC

Now that we have a graph of a bunch of objects with randomized
attributes, we need a way to extract these attributes out of the
entire collection of nodes in the graph.  We define
=get_attribute(attr)= to construct a list of values:
#+BEGIN_LaTeX
  \[
    \{\text{$n$.attribute} : n \in G\}
  \]
#+END_LaTeX
and an averaging function to average numerical values:
#+BEGIN_LaTeX
  \[
  \frac{1}{|G|}\sum_{n \in G}{\text{$n$.attribute}}
  \]
#+END_LaTeX
#+BEGIN_SRC python :noweb-ref "define helper functions"
  def get_attribute(self, attr):
      return map(lambda n: getattr(n, attr), self.G.nodes())

  def avg(self, attr):
      return float(sum(self.get_attribute(attr)))/len(self.G.nodes())
#+END_SRC

We are ready to implement our tests.  For =bool=, =float=, and =int=,
we test to make sure the average values we collect from the generated
graph match the theoretical averages (the ones we gave to target). For
the special =func= case, we do something a little fancier.

To test the =func= case, we count the occurances of each possible
=answer= and find its absolute variance from the theoretical value it
should have ($1000/3=333.\bar3$).  We then sum those variances and
ensure it is less than some (generous) threshold value.
#+BEGIN_SRC python :noweb-ref "test randomness"
  def test_bool(self):
      assert_almost_equal(self.avg('marked'), .3, 1)
    
  def test_float(self):
      assert_almost_equal(self.avg('weight'), .5, 1)
    
  def test_int(self):
      g = self.avg('age')
      e = (18.0 + 65)/2
    
      assert_almost_equal(g/100, e/100, 1)
    
  def test_func(self):
      g = sum([abs(self.get_attribute('answer').count(c) - 333.33) / 1000.0
               for c in ['yes', 'no', 'maybe']])
    
      assert_less(g, .1)
#+END_SRC

