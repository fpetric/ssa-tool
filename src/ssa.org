#+Title: Working with Self-Stabilizing Algorithms in Python
#+Author: Sean Allred
#+Date: [2013-12-24 Tue]

#+PROPERTY: noweb tangle
#+PROPERTY: mkdirp yes

#+TODO: TODO INPROGRESS WRITE_TESTS WISH_LIST | DONE

* Notes
** Dijkstra 1974
A self-stabilizing network is seen as a graph of state machines.  Each
privilege is realized as a transition from the current state to
another state.  The state of the graph is passed as input to this
state machine.  When the input graph matches some predicate, this
privilege is set---there is some transition out of this state.  This
is why the choice of predicate to act upon is arbitrary: you can only
move to one other state!

When every node of the graph is in an accepting state with no set
predicates, then the graph has stabilized.

*** privilege
- we consider graphs of finite state machines
- privileges are boolean functions of the FSM's state and the states
  of its neighbors
- when these functions are true, the privilege is 'present'
*** system state
- each legitimate state must have at least one privilege present
  - even if the action is 'do nothing'
- in each legitimate state, every possible action will maintain
  legitimacy
- each privilege must be present in at least one legitimate state
- for any given pair of legitimate states, there exists a
  transformation between them
*** self-stabilization
regardless of the initial state and regardless of the privilege
selected each time for the next move, at least one privilege will
always be present and the system is guaranteed to find itself in a
legitimate state after a finite number of moves.

* Introduction
:PROPERTIES:
:ID:       50650171-2D03-4633-B4A9-625372F23D79
:END:
The project is set up as a [[http://learnpythonthehardway.org/book/ex46.html][traditional Python module]]:
#+BEGIN_EXAMPLE
  setup.py
  ssa/
      __init__.py
      core/
          __init__.py
      creation/
          __init__.py
      simulation/
          __init__.py
  bin/
  docs/
  tests/
      __init__.py
      core_tests.py
      creation_tests.py
      simulation_tests.py
#+END_EXAMPLE
#+BEGIN_SRC python :tangle "./setup.py"
  try:
      from setuptools import setup
  except ImportError:
      from distutils.core import setup
  
  config = {
      'description': 'A utility for the creation and evaluation of self-stabilizing algorithms',
      'author': 'Sean Allred',
      'url': 'http://github.com/vermiculus/smp',
      'download_url': 'http://github.com/vermiculus/smp',
      'author_email': 'seallred@smcm.edu',
      'version': '0.1',
      'install_requires': ['networkx', 'pygame'],
      'packages': ['ssa'],
      'scripts': [],
      'name': 'ssa',
      'py_modules': ['core', 'creation', 'simulation']
  }
  
  setup(**config)
#+END_SRC
#+BEGIN_SRC python :tangle "ssa/__init__.py"
  import core
  import creation
  import simulation
#+END_SRC
** TODO Fix =python setup.py install= sequence
It's saying I need a couple files:
#+BEGIN_EXAMPLE
  core.py
  creation.py
  simulation.py
#+END_EXAMPLE
but what goes in them?  I opened up a [[http://stackoverflow.com/questions/21685430/when-running-setup-py-install-on-my-module-what-needs-to-be-in-submodule-p][question on StackOverflow]], but
I'm not hopeful about getting any responses.
* Core Classes
:PROPERTIES:
:ID:       9A6247A9-9F24-4A97-9161-CC87C2AC8786
:END:
#+BEGIN_SRC python :tangle "ssa/core/__init__.py"
  from .. import creation
  from .. import simulation
#+END_SRC
In Dijkstra's 1974 paper, he describes a self-stabilizing algorithm as
a graph of state-machines:
#+BEGIN_QUOTE
We consider a connected graph in which the majority of the possible
edges are missing and a finite state machine is placed at each node;
machines placed in directly connected nodes are called each other's
neighbors.  For each machine one or more so-called "privileges" are
defined, i.e. boolean functions of its own state and the states of its
neighbors; when such a boolean function is true, we say that the
privilege is "present."  In order to model the undefined speed ratios
of the various machines, we introduce a central daemon---its
replacement by a distributed daemon falls outside the scope of this
article---that can "select" one of the privileges present.  The
machine enjoying the selected privilege will then make its "move";
i.e. it is brought into a new state that is a function of its old
state and the states of its neighbors.  If for such a machine more
than one privilege is present, the new state may also depend on the
privilege selected.  After completion of the move, the daemon will
select a new privilege.
#+END_QUOTE
Thus, we need to create a new class to act as the nodes of a NetworkX
graph.  This new node class will impose a collection of privileges
upon the object---privilege functions that must be additionally given
the collection of its neighbors.  These privilege functions do, of
course, return =True= or =False=.

Here comes the fun part: the new node class has a property (or rather,
a function =privileges_present=, TODO "python property act like a
function") that returns the identifications of all privileges that are
active---all those privileges of the node that return =True=---and
these identifications are then linked by a mapping within the node to
actions that they apply to.

** DONE Dependencies
:PROPERTIES:
:ID:       EFAAB89D-EF82-4DE4-A144-5268FC1A11F8
:END:
#+BEGIN_SRC python :tangle "ssa/core/__init__.py"
  from TeXableEntity import TeXableEntity
  from Action import Action
  from Predicate import Predicate
  from FiniteStateMachine import FiniteStateMachine
#+END_SRC
** DONE TeXable Entity
:PROPERTIES:
:ID:       BFE270CC-AD8D-4A10-B695-6F90BADA1C55
:END:
Since this is all math and this research uses TeX almost exclusively,
it is worthwhile to include auto-generation of TeX documentation for
the algorithm.

A =TeXableEntity= is an object that has both human-readable
documentation and a TeX representation.  The documentation is what is
returned when the object is interpreted as a string, and the TeX
representation is the first part of the returned tuple when the object
is asked for its own representation.
#+BEGIN_SRC python :tangle "ssa/core/TeXableEntity.py"
  class TeXableEntity:
      """A documented object
  
      TeXableEntity is a very simple base class for mathematics-based
      objects (such as FiniteStateMachine).  It is assumed that the
      first bit is pure mathematics (something to be placed inside an
      'align' environment).
  
      >>> t = TeXableEntity('x', 'The variable $x$')
      >>> t
      TeXableEntity(TeX='x', doc='The variable $x$')
  
      >>> t.TeX
      'x'
  
      >>> t.doc
      'The variable $x$'
  
      >>> eval(repr(t)) == t
      True
      """
      __initializer = 'TeXableEntity(TeX={TeX!r}, doc={doc!r})'
      def __init__(self, TeX=None, doc=None):
          self.TeX = TeX
          self.doc = doc
  
      def __repr__(self):
          return self.__initializer.format(**self.__dict__)
  
      def __str__(self):
          return str(self.doc)
      
      def __eq__(self, other):
          if isinstance(other, TeXableEntity):
              return self.TeX == other.TeX and self.doc == other.doc
          else:
              return False
  
  if __name__ == '__main__':
      import doctest
      doctest.testmod()
#+END_SRC
** INPROGRESS Finite State Machine
:PROPERTIES:
:ID:       E9B1FF06-C88E-4CF6-A30C-D9F7D17E326F
:END:
#+BEGIN_SRC python :tangle "ssa/core/FiniteStateMachine.py"
  from TeXableEntity import TeXableEntity
  
  class FiniteStateMachine(TeXableEntity):
      def __init__(self,
                   alphabet      = set(),
                   states        = set(),
                   initial_state = None,
                   accept_states = set(),
                   transitions   = dict()):
  
          self.accept_states = accept_states
          self.initial_state = initial_state
          self.states        = states
          self.alphabet      = alphabet
          self.transitions   = transitions
  
      <<machine editing>>
  
      <<machine functionality>>
#+END_SRC
*** INPROGRESS Machine Editing
:PROPERTIES:
:noweb-ref: "machine editing"
:noweb-sep: "\n\n"
:END:
**** WRITE_TESTS Transitions
Here we add logic supporting on-the-fly addition of transitions.  If
either the =source= or =destination= states are not in the set of
states, they will be added.

If the transition is already defined, a =KeyError= will be raised.
#+BEGIN_SRC python
  def add_transition(self, source, token, destination):
      """Adds a transition from source to destination on an input
      token.
  
      If such a transition is already defined, a KeyError will be
      raised.
      """
      self.states.add(source)
      self.states.add(destination)
  
      if source not in self.transitions:
          self.transitions[source] = dict()
      elif token in self.transitions[source]:
          raise KeyError('Input token already defined for source.')
  
      self.transitions[source][token] = destination
#+END_SRC

**** WRITE_TESTS Initial State
#+BEGIN_SRC python
  def set_initial_state(self, state):
      """Set the initial state for this machine.
  
      If the given state is not in the machine's set of states, it will
      be added.
      """
      self.states.add(state)
      self.initial_state = state
#+END_SRC

**** TODO Alphabet

**** TODO Accept States

*** TODO Machine Functionality
:PROPERTIES:
:noweb-ref: "machine functionality"
:noweb-sep: "\n\n"
:END:
**** WISH_LIST add an input buffer
It'd be cool to have an input buffer to push an entire sentence.  I
don't know how useful it would be in the current overall project, but
perhaps this could be made more robust and separated out into its own
module.
**** WRITE_TESTS Resetting the Machine
#+BEGIN_SRC python
    def reset(self):
        self.current_state = self.initial_state
#+END_SRC

**** WRITE_TESTS Receiving Input
#+BEGIN_SRC python
  def update(self, token):
      """Updates the state of the machine according to the input token.
  
      If the input token is not defined for the current state, an
      Exception is raised to signal failure.
      """
      if token in self.transition[self.current_state]:
          self.current_state = self.transition[self.current_state][token]
      else:
          raise Exception('The machine has rejected your input')
#+END_SRC
**** DONE Reporting State
You can grab the current state of the machine by looking at the value
of =FiniteStateMachine.current_state=.
***** WISH_LIST Perhaps unsafe.
** Predicates and Actions
Predicates and Actions are very similar to each other.
*** TODO TeX-enabled predicates/actions
Create a class for =Predicate= and =Action= that both inherit from
=TeXableEntity=.  We should be able to attach TeX documentation to
rules and predicates so that we can have a nice display of the entity.

This could also be useful in export.
*** Predicates
:PROPERTIES:
:ID:       0DD0C7C1-F462-4F1B-B5C9-E9418CAA8E99
:END:
#+BEGIN_SRC python :tangle "ssa/core/Predicate.py"
  from TeXableEntity import TeXableEntity
  class Predicate(TeXableEntity):
      """A function from G, v -> {True, False}

         <<class predicate documentation>>
      """
      def __init__(self, predicate = lambda graph, node: True,
                         as_TeX    = None,
                         doc       = None):
          TeXableEntity.__init__(self, as_TeX, doc)
          self.predicate = predicate
  
      def __call__(self, graph, node):
          return self.predicate(graph, node)
#+END_SRC
**** Online Documentation
:PROPERTIES:
:noweb-ref: class predicate documentation
:ID:       197C9408-92F9-4AFC-8ADD-9E11A184CCCD
:END:
#+BEGIN_SRC markdown
  A `Predicate` consists of two parts:
  
    - documentation (both TeXnical and human-readable)
  
          >>> TeX_documentation   = 'G, v \mapsto \dots'
          >>> human_documentation = 'Returns true when $v$ has' +
                                    'more than one marked neighbor.'
  
    - predicate function, which can be a pure 'lambda' function:
  
          >>> lambda_predicate = lambda G, v: v in G
  
      or the name of a full-on function:
  
          >>> def fulldef_predicate(graph, node):
          ...     number_marked = 0
          ...     for neighbor in graph.neighbors(node):
          ...         if neighbor.marked:
          ...             number_marked += 1
          ...         if number_marked > 1:
          ...             return True
          ...     return False
  
  We can create a `Predicate` object using these three parts like so:
  
      >>> predicate = Predicate(fulldef_predicate,
      ...                       TeX_documentation,
      ...                       human_documentation)
  
  Our `Predicate` object will now behave like a function, able to be
  called with two arguments (a graph and a node) for a natural feel.
  Let's create a random graph and get a random node in that graph;
  hopefully we'll get lucky!
  
      >>> from generators import random_graph
      >>> from random import choice
      >>> G = random_graph(              \
            (20, 30),                    \
            .8,                          \
            marked='bool(.8)')
      >>> some_node = choice(G.nodes())
  
  Now that we have `G` and `some_node` in `G`, we can test to see if the
  predicate is true for that node in `G`:
  
      >>> predicate(G, some_node)                   # doctest: +SKIP
      True
#+END_SRC
*** Actions
:PROPERTIES:
:ID:       03B2B5CE-6839-4400-ABC3-1E16764142A8
:END:
#+BEGIN_SRC python :tangle "ssa/core/Action.py"
  from TeXableEntity import TeXableEntity
  class Action(TeXableEntity):
      """A function from G, v -> G'
  
      <<class action documentation>>
      """
      def __init__(self, action = lambda graph, node: graph,
                         as_TeX = None,
                         doc    = None):
          TeXableEntity.__init__(self, as_TeX, doc)
          self.action = action
  
      def __call__(self, graph, node):
          return self.action(graph, node)
#+END_SRC
**** Online Documentation
:PROPERTIES:
:noweb-ref: class action documentation
:END:
#+BEGIN_SRC markdown
  Create an action like so:
  
      >>> action = Action(lambda G, v: v['marked'] = True,
                          'v.marked \gets True',
                          'Marks $v$')
  
  You can retrieve the documentation and TeX representation of the
  object as you would a `TeXableEntity`:
  
      >>> action.doc
      'Mark $v$'
      >>> action.TeX
      'v.marked \gets True'
  
  You can also *call* `Action` objects, passing a graph and node as
  arguments.  This functionality is deferred to the member function
  `Action.action`.
#+END_SRC
** Self-Stabilizing Algorithm
:PROPERTIES:
:ID:       178FB0D4-0E4C-4458-B0BF-C8F01662998B
:END:
- a dictionary from =Rule= objects to sets of =Predicate= objects.
- also a =TeXableEntity=

old code
#+BEGIN_SRC python :tangle "ssa/core/SelfStabilizingAlgorithm.py"
  """
  Base class for self-stabilizing algorithms.
  """
  
  __author__ = "Sean Allred (seallred@smcm.edu)"
  
  import networkx as nx
  import random
  
  class SelfStabilizingAlgorithm:
      """Base class for self-stabilizing algorithms.
  
      The SelfStabilizingAlgorithm class represents its namesake as a set
      of predicate-action pairs.
      """
      def __init__(self, rules=dict()):
          self.rules = rules
  
          for predicates in rules.keys():
              if not hasattr(predicates, '__getitem__'):
                  predicates = [predicates]
              for p in predicates:
                  self.add_rule(predicate, rules[predicate])
  
      def add_rule(self, predicate=lambda graph, privileged_node: True,
                         action=lambda graph, privileged_node: graph):
          """Add a rule to this algorithm.
  
          Parameters
          ----------
          predicate : f: (graph, node) \to {True, False}
          action :    f: (graph, node) \to graph
          """
          if predicate in self.rules:
              self.rules[predicate].append(action)
          else:
              self.rules[predicate] = [action]
  
      def apply_to(graph, count=1, keep_history=False):
          """Apply this algorithm to `graph` `count` times.
  
          Algorithm
          ---------
          Initialize this history and the current graph.  For as many
          times specified by `count`, do the following:
  
             1. Create a set of nodes that we need to check in this round,
                initialized to the complete set of nodes currently in the
                graph.
             2. While we have nodes to check,
                2.1 Randomly choose a privileged node from the set of
                    unchecked nodes.
                2.2 Create a set of all predicates that apply to the              # TODO: unnecessary to check them all
                    privileged node.
           ,*    2.3 If this set is not empty, choose a random predicate
                    from that set.  Otherwise, break out of the while
                    loop, leaving the matching predicate as a None-value
                    (see step 3).
                2.4 Remove this node from the set of unchecked nodes
           ,* 3. If the matching predicate is None, break.  There is no
                point in continuing to check since the state of the
                graph will no longer change.
             4. Retrieve the approriate action for the matching
                predicate.
             5. Update the current graph by applying the action
                appropriately.
             6. If we are keeping history, record the necessary elements
                and update the current graph to a deep copy of itself.
  
          (*) Represents a step where program flow may be redirected.
  
          Returns
          -------
          If `keep_history` is specified, the function will return a
          history (as a list of 3-tuples) that map the current state of
          the graph to the predicate and node that caused it.
          """
          history = [(graph, None, None)]
  
          if keep_history:
              current_graph = graph.copy()
          else:
              current_graph = graph
  
          for i in range(count):
              unchecked_nodes = current_graph.get_nodes()[:]
  
              privileged_node = None
              matching_predicate = None
  
              while unchecked_nodes:
                  privileged_node = random.choice(unchecked_nodes)
  
                  # I'm not using shuffle because "Note that for even
                  # rather small len(x), the total number of
                  # permutations of x is larger than the period of most
                  # random number generators; this implies that most
                  # permutations of a long sequence can never be
                  # generated."
                  preds = [p for p in self.rules.keys()]
                  while preds:
                      matching_predicate = random.choice(preds)
  
                      if p(current_graph, privileged_node):
                          break
  
                      preds.remove(matching_predicate)
  
                  unchecked_nodes.remove(privileged_node)
  
              if matching_predicate is None: break
              else:
                  matching_action = random.choice(self.rules[matching_predicate])
                  current_graph = matching_action(current_graph,
                                                  privileged_node)
  
                  if keep_history:
                      history.append((current_graph,
                                      matching_predicate,
                                      privileged_node))
                      current_graph = current_graph.copy()
  
          if keep_history:
              return history
          else:
              return graph
#+END_SRC
** TODO Algorithm
#+BEGIN_SRC python :tangle "ssa/core/Algorithm.py"
  from ssa.core import TeXableEntity
  from ssa.core import Predicate
  from ssa.core import Action
  class Algorithm(TeXableEntity):
      """A self-stabilizing algorithm
  
      <<class algorithm documentation>>
      """
      def __init__(self, TeX,
                         doc,
                         pa):
          self.TeX = TeX
          self.doc = doc
          self.pa  = pa
  
      <<class algorithm run>>

      <<class algorithm stability>>

      <<class algorithm construction>>
#+END_SRC
*** Running the Algorithm
:PROPERTIES:
:noweb-ref: class algorithm run
:END:
Since algorithms may take many iterations to converge, the following
function is provided in such a way so that it can take a number of
times to execute the algorithm.  This value defaults to 1.
#+BEGIN_SRC python
  def run(self, graph, count=1):
      """Run the algorithm `n` times.
  
      <<class algorithm run documentation>>
      """
      assert n >= 0
      while n > 0:
          <<class algorithm run once>>
#+END_SRC
**** TODO Running it Once
:PROPERTIES:
:noweb-ref: class algorithm run once
:END:
To run the algorithm once, we would say the following.
#+BEGIN_SRC python
  pass
#+END_SRC
*** Stability Analysis
**** Determining if the Algorithm has Stabilized
:PROPERTIES:
:noweb-ref: class algorithm stability
:END:
#+BEGIN_SRC python
  def has_stabilized(self):
      """Returns True if the graph has stabilized.
  
      This function runs `Algorithm.run` twice."""
      pass
#+END_SRC
**** Running Until Stabilization
This is not recommended as there can be no guarantee of halt, but the
following is provided for completeness.
#+BEGIN_SRC python
  def stabilize(self, graph):
      while not self.has_stabilized():
          self.run(graph)
#+END_SRC
* Creation
:PROPERTIES:
:ID:       5E7F7349-CAC3-4CDB-814C-01B01F63E7D0
:END:
A graphical tool for the creation of self-stabilizing algorithms
#+BEGIN_SRC python :tangle "ssa/creation/__init__.py"

#+END_SRC
* INPROGRESS Simulation
:PROPERTIES:
:ID:       017756B6-C2B1-4224-A8B0-98F0944EF921
:END:
#+BEGIN_SRC python :tangle "ssa/simulation/__init__.py"
  import generators
  from ColorBank import ColorBank
  from BasicNode import BasicNode
#+END_SRC
** Displaying a Graph
*** Managing Colors
:PROPERTIES:
:ID:       FA752FEE-D647-4156-9E58-9EE8EBE8F502
:END:
#+BEGIN_SRC python :tangle "ssa/simulation/ColorBank.py"
  class ColorBank:
      def __init__(self):
          self.black = (0, 0, 0)
          self.white = (255, 255, 255)
          self.red   = (255, 0, 0)
          self.green = (0, 255, 0)
          self.blue  = (0, 0, 255)
  
      def set_color(self, name, red, green, blue):
          setattr(self, str(name), (red, green, blue))
  
      @classmethod
      def get_inverse(cls, color, alpha=1):
          inverses = [255 - c for c in color] + [alpha]
          return tuple((channel for channel in inverses))
  
      @classmethod
      def random(cls, r):
          return tuple((r.randint(0, 255) for i in range(3)))
#+END_SRC
*** A Basic Node
:PROPERTIES:
:ID:       72CC2548-41E1-4A16-A3BA-E3AE9DBA28DB
:END:
#+BEGIN_SRC python :tangle "ssa/simulation/BasicNode.py"
  from ColorBank import ColorBank

  class BasicNode:
      default_radius = 25
      default_color = (0,0,0)
      default_data = None
      default_position = (0, 0)
  
      def __init__(self, position=None,
                         radius=None,
                         color=None,
                         data=None,
                         randomize=None):
          if randomize is not None:
              r=randomize
              if data         is None: data       = '(random)'
              if color        is None: color      = ColorBank.random(r)
              if radius       is None: radius     = r.randint(3,50)
              if position     is None: position   = (r.random(), r.random())
          else:
              if data         is None: data       = BasicNode.default_data
              if color        is None: color      = BasicNode.default_color
              if radius       is None: radius     = BasicNode.default_radius
              if position     is None: position   = BasicNode.default_position
  
          if any(map(lambda c: not (0 <= c <= 1), position)):
              raise Exception('Woah there buddy.')
  
          self.data       = data
          self.color      = color
          self.radius     = radius
          self.position   = position
      def __str__(self):
          return str(self.data)
      def __repr__(self):
          return str(self.__dict__)
#+END_SRC
*** Displaying the Game Window
:PROPERTIES:
:ID:       15876325-7EB7-4943-9B28-377F5F4B3EA6
:END:
#+BEGIN_SRC python :tangle "ssa/simulation/Visualizer.py"
  import pygame
  import networkx as nx
  
  from ColorBank import ColorBank
  from BasicNode import BasicNode
  
  class Visualizer:
      def __init__(self, size=(640, 480), graph=nx.Graph(), edge_width = 2):
          """where `size` is a 2-tuple representing screen dimens"""
  
          self.screen = pygame.display.set_mode(size)
  
          self.colors = ColorBank()
          self.graph = graph
          self.edge_width = edge_width
          self.layout_algorithms = [getattr(nx, a) for a in dir(nx) if a.endswith('_layout')]
          # TODO sometimes crashes here; why?
          self.text_font = pygame.font.SysFont('monospace', 15)
  
      def do_layout(self, layout_algorithm=nx.spring_layout):
          try:
              p = layout_algorithm(self.graph)
          except:
              print 'Layout algorithm `{!s}` not yet supported.'.format(repr(layout_algorithm).split()[1])
              print 'Please install the appropriate package.'
              return
  
          for node, position in zip(p.keys(), p.values()): # in p isn't working: iteration over non-sequence
              self.graph.node[node]['position'] = ((position[0] + 1) / 2, (position[1] + 1) / 2)
  
      def draw(self):
          self.screen.fill(self.colors.green)
          size = self.screen.get_size()
  
          for src, dst in self.graph.edges():
              pygame.draw.line(self.screen, self.colors.white,
                               self.floats_to_pos(self.graph.node[src]['position']),
                               self.floats_to_pos(self.graph.node[dst]['position']), self.edge_width)
  
          for node, node_data in self.graph.nodes(data=True):
              normal_pos = self.floats_to_pos(node_data['position']) # keep track of z order for drag drop
              pygame.draw.circle(self.screen, node_data['color'], normal_pos, node_data['radius'], 0)
              label = self.text_font.render(str(node_data['data']), True, ColorBank.get_inverse(node_data['color']))
              self.screen.blit(label, normal_pos)
  
          pygame.display.update()
  
      def floats_to_pos(self, floats):
          return tuple((int(coordinate * scale) for coordinate, scale in zip(floats, self.screen.get_size())))
  
      def pos_to_floats(self, position):
          return tuple((coordinate / scale for coordinate, scale in zip(position, self.screen.get_size())))
  
      def loop(self):
          """Runs the simulator.
  
          >>> pygame.init()
          (6, 0)
          >>> Visualizer(size=(640, 480), graph=make_graph()).loop()
          """
          ingame=True
          for i in range(3):
              self.graph = make_graph()
              for i in range(10):
                  self.do_layout()
                  self.draw()
                  pygame.time.delay(50)
              for event in pygame.event.get():
                  if event.type == pygame.QUIT:
                      pygame.quit()
                      ingame = False
          pygame.quit()
  
  import generators
  make_graph = lambda: \
      generators.random_graph((5, 20), .3,
                              data=(i for i in range(50)),
                              color=lambda r: ColorBank.random(r),
                              radius='int(3, 10)',
                              position=lambda r: tuple([r.random(), r.random()]))
    
  if __name__ == '__main__':
      import doctest
      doctest.testmod()
#+END_SRC
** Generators
:PROPERTIES:
:ID:       0791B53E-7544-43A0-B5D0-713F3199FE0A
:END:
#+BEGIN_SRC python :tangle "ssa/simulation/generators.py"
  import networkx
  import random
  from itertools import combinations
  
  class BasicNode:
      def __init__(self):
          pass
      def __repr__(self):
          return '{}::{}'.format(id(self), self.__dict__)
  
  <<random graphs>>

  if __name__ == '__main__':
      import doctest
      doctest.testmod()
#+END_SRC
*** Generating a Random Graph
    :PROPERTIES:
    :noweb-ref: random graphs
    :ID:       C315D9D2-BE1C-447A-8961-4080AFD9B648
    :END:
To thoroughly test graph algorithms (in lieu of or in preparation for
proof), it is very useful to have a means to create randomized graphs
with certain characteristics.  NetworkX has a few generators at its
disposal for creating graphs with deeper properties than I have
knowledge of, but the following function is able to create a random
graph with nodes having randomized properties.
#+BEGIN_SRC python
  def random_graph(degree, edge_probability=0.5, base_class=BasicNode, **properties):
      """Generates a random graph of `degree` nodes, a specified
      probability for edges, and a number of random properties.
      
      <<summary>>
  
      <<doctest basic usage>>
  
      <<doctest errors>>
      """
      r = random.Random()
      G = networkx.Graph()

      <<check if degree is range>>
  
      <<check for dynamically-created generators>>
  
      for n in range(degree):
          <<add node>>
  
      <<add edges>>
      
      return G
#+END_SRC
**** Documentation
***** Summary
    :PROPERTIES:
    :noweb-ref: summary
    :END:
#+BEGIN_SRC markdown
  If `degree` is a tuple, it is assumed to be a (min, max) tuple
  defining an inclusive range of possible degrees.
    
  Each `properties` value can be a function of a random number
  generator.  If the value does not have `__call__` defined, it will be
  assumed a string unless, as a string, it is one of the following:
    
  - 'int(n,m)' :: a random integer in [n, m]
  - 'float()'  :: a random floating point number in [0, 1)
  - 'bool(n)'  :: a random boolean with a probability of truth between 0
                  and 1 inclusive (where 1 is True).
    
  If the property value is neither callable nor a string of this form,
  then the value is simply set raw.
#+END_SRC
***** Basic Usage
    :PROPERTIES:
    :noweb-ref: doctest basic usage
    :END:
#+BEGIN_SRC markdown
  Pass in a single argument, the degree of the graph, to get the
  bare-minimum graph (with a certain edge probability):
    
      >>> G = random_graph(50)
      >>> len(G.nodes())
      50
  
  Pass in a tuple to get a range of values:
    
      >>> G = random_graph((40, 60))
      >>> len(G.nodes()) in range(40, 60 + 1)
      True
    
  You can also use a few intelligent arguments, such as bool(n):
  
      >>> G = random_graph(10, marked='bool(1)')
      >>> all(map(lambda n: G.node[n]['marked'], G.node))
      True
      >>> G = random_graph(10, marked='bool(0)')
      >>> any(map(lambda n: G.node[n]['marked'], G.node))
      False
    
  float():
  
      >>> G = random_graph(1000, weight='float()')
      >>> .45 < sum(map(lambda n: G.node[n]['weight'], G.node)) / 1000 < .55
      True
    
  and int(min, max):
    
      >>> G = random_graph(10, age='int(40, 50)')
      >>> all(map(lambda n: G.node[n]['age'] in range(40, 50 + 1), G.node))
      True
  
  For any attribute, you can specify a function or a generator.  You can
  even supply a function that *returns* a generator.  All functions must
  take exactly one required argument, a random number generator, as its
  first parameter.
  
  (ref:smp - optionify random thingy)
  
  Consider the following:
  
      >>> graph = random_graph(5, weight=(i for i in range(5)))
      >>> sorted([graph.node[n]['weight'] for n in graph.nodes()])
      [0, 1, 2, 3, 4]
  
                                                                           (ref:)
#+END_SRC

***** Possible Errors
    :PROPERTIES:
    :noweb-ref: doctest errors
    :END:
#+BEGIN_SRC markdown
  Be careful about the arguments you pass.  If you want a range of
  possible values for the degree, ensure you pass an iterable of exactly
  two elements.
    
      >>> random_graph((1,2,3))
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      ValueError: Wrong number of values for (min, max) degree
    
  Mind the arguments for the keywords 'bool', 'int', and 'float'.
    
      >>> random_graph(5, marked='int(3,4,5)')
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      ValueError: Wrong number of arguments for int.
  
  If you are using generators, keep in mind that *each* node must be
  given a value.  If the generator produces less values than you give
  the graph nodes, an exception will be raised:
  
      >>> n = 5
      >>> g = random_graph(n + 1, weight=(i for i in range(n)))
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      Exception: Ran out of iterations for the generator given by 'weight'
#+END_SRC
**** Code
***** Check Degree
     :PROPERTIES:
     :noweb-ref: check if degree is range
     :END:
#+BEGIN_SRC python
  if hasattr(degree, '__getitem__'):
      if len(degree) is not 2:
          raise ValueError('Wrong number of values for (min, max) degree')
      degree = r.randint(*degree)
#+END_SRC
***** Check for Dynamic Generators
:PROPERTIES:
:noweb-ref: check for dynamically-created generators
:END:
In playing with the tool for a while, I've come to see a few use cases
for the ability to create 'on the fly' generators with lambda
expressions.  The code currently checks for functions by checking if
they define =__call__=, and this is good behavior.  However, it is
possible that such a function could return a generator object, so we
need to run through each property /first/ to check if calling any
existing functions yields a generator (no pun intended).
#+BEGIN_SRC python
  for key in properties:                  
      if hasattr(properties[key], '__call__'):
          check_value = properties[key](r)
          if hasattr(check_value, 'next'):
              properties[key] = check_value
#+END_SRC
***** Adding Nodes
     :PROPERTIES:
     :noweb-ref: add node
     :END:
#+BEGIN_SRC python
  new_node = base_class()

  G.add_node(new_node)
      
  for key in properties:
      property_key = str(key)
      property_value = properties[key]
      
      <<check for property overwrite>>
      
      <<parse and set property value>>
#+END_SRC
****** Property Overwrite
     :PROPERTIES:
     :noweb-ref: check for property overwrite
     :END:
#+BEGIN_SRC python
  # Avoid overwriting properties.  This could happen if the
  # user passes in something that is a dictionary rather
  # than a traditional KV list.  We'll accept anything that
  # has __str__, but __str__ is not meant to be unique.
  if hasattr(new_node, property_key): 
      raise Exception('Did not overwrite duplicate property')
#+END_SRC
****** Property Set
     :PROPERTIES:
     :noweb-ref: parse and set property value
     :END:
The new value can be a couple things.  If it is a callable function
(implements =__call__=), we assume it is some function that expects a
=random.Random= object as its single required parameter.  If it is a
generator (implements =next=), we retrieve the next value.  Otherwise,
we parse =property_value= as a string
#+BEGIN_SRC python
  new_value = None
    
  if hasattr(property_value, '__call__'):
      new_value = property_value(r)
  elif hasattr(property_value, 'next'):
      try:
          new_value = next(property_value)
      except StopIteration:
          raise Exception('Ran out of iterations for the generator given by {!r}'\
                              .format(property_key))
  elif '(' in property_value and ')' in property_value: # val is a func
      # collect the arguments
      # TODO: make this safe, i.e. destroy `eval`
      func = property_value[:property_value.index('(')]
      args = eval(property_value[property_value.index('('):])
      ex = lambda t: ValueError('Wrong number of arguments for {}.'.format(t))
      
      if func == 'float':
          if len(args) is not 0: raise ex('float')
          new_value = r.random()
      elif func == 'int':
          if len(args) is not 2: raise ex('int')
          new_value = r.randint(*args)
      elif func == 'bool':
          new_value = r.random() <= float(args)
  else:
      new_value = property_value
  
  G.node[new_node][property_key] = new_value
#+END_SRC
******* WISH_LIST Enhance security
We have the line =args=eval(property_value[...])=.  This should be
fine given the audience, but it is terribly unsafe.  Find a better way.

Perhaps we can represent arguments as tuples, LISP-style?
#+BEGIN_EXAMPLE
  random_graph(15,
    marked = ('bool', .3)
    weight = ('float',)
    ranged = ('float', 5, 7)
    more_r = ('range', 1, 10))
#+END_EXAMPLE
with =range= taking place of =int(...)=.
***** Adding Edges
     :PROPERTIES:
     :noweb-ref: add edges
     :END:
#+BEGIN_SRC python
  for src, dst in combinations(G.nodes(), 2):
      # perhaps add switch to check for __call__(node_a, node_b)
      if r.random() <= edge_probability:
          G.add_edge(src, dst)
#+END_SRC
** On-screen animation
** Step-by-Step TeX Print-Outs
* Tests
We will be using the Nose toolset for automated testing.
#+BEGIN_SRC python :noweb-ref "common imports for testing"
  import unittest
  from nose.tools import *
#+END_SRC
** Core
:PROPERTIES:
:ID:       6C18CD91-679E-4835-9E2A-C4BCF1C506FB
:END:
#+BEGIN_SRC python :tangle "tests/core_tests.py"

#+END_SRC
** Creation
:PROPERTIES:
:ID:       F45B85F5-9690-4AFB-8A21-D27FA0DDC803
:END:
#+BEGIN_SRC python :tangle "tests/creation_tests.py"

#+END_SRC
** Simulation
:PROPERTIES:
:ID:       328AAB02-1AAC-4A0C-ADCE-54962602181A
:END:
#+BEGIN_SRC python :tangle "tests/simulation_tests.py"
  <<common imports for testing>>
  from ssa.simulation import *
  <<random graph test>>
#+END_SRC
*** Random Graph Generation
:PROPERTIES:
:tests:    [[id:C315D9D2-BE1C-447A-8961-4080AFD9B648][Generating a Random Graph]]
:noweb-ref: random graph test
:END:
This test is structured as those above, with a few specializations.
Since the random graph generator does not (and should not) create
predictable or reproducible results, we must create a very large
random graph (1000 nodes) and then perform some analysis on that same
graph multiple times.  (Otherwise, the tests would hang on this
portion for some time.)

We import all those classes that we need to and define a testing class
to contain the random graph in the correct scope.  After we define a
few helper functions to look at only one attribute at a time, we then
make our assertions on what the results /should/ look like.
#+BEGIN_SRC python
  class RandomGraphTest(unittest.TestCase):
      @classmethod
      def setupClass(cls):
          cls.G = \
          <<create random graph>>
  
      <<define helper functions>>
  
      <<test randomness>>

      <<test functions and generators>>
#+END_SRC

**** Creating the Graph
:PROPERTIES:
:noweb-ref: create random graph
:END:
We create a random graph with the following properties:
- degree :: 1000
- edge probability :: 70%
- marked :: 30% chance of being marked
- answer :: equal chances of being 'yes', 'no', or 'maybe'
- weight :: a random real in [0, 1)
- age :: a random number between 18 and 65
#+BEGIN_SRC python
  generators.random_graph(\
      1000, .7,
      marked='bool(.3)',
      answer=lambda r: r.choice(['yes', 'no', 'maybe']),
      weight='float()',
      age='int(18, 65)')
#+END_SRC
**** Define Helper Functions
:PROPERTIES:
:noweb-ref: define helper functions
:END:
Now that we have a graph of a bunch of objects with randomized
attributes, we need a way to extract these attributes out of the
entire collection of nodes in the graph.  We define
=get_attribute(attr)= to construct a list of values:
#+BEGIN_LaTeX
  \[
    \{\text{$n$.attribute} : n \in G\}
  \]
#+END_LaTeX
and an averaging function to average numerical values:
#+BEGIN_LaTeX
  \[
  \frac{1}{|G|}\sum_{n \in G}{\text{$n$.attribute}}
  \]
#+END_LaTeX
#+BEGIN_SRC python
  def get_attribute(self, attr):
      return map(lambda n: self.G.node[n][attr], self.G.node)
  
  def avg(self, attr):
      return float(sum(self.get_attribute(attr)))/len(self.G.nodes())
#+END_SRC
**** Testing Randomness
:PROPERTIES:
:noweb-ref: test randomness
:END:
We are ready to implement our tests.  For =bool=, =float=, and =int=,
we test to make sure the average values we collect from the generated
graph match the theoretical averages (the ones we gave to target). For
the special =func= case, we do something a little fancier.

To test the =func= case, we count the occurances of each possible
=answer= and find its absolute variance from the theoretical value it
should have ($1000/3=333.\bar3$).  We then sum those variances and
ensure it is less than some (generous) threshold value.
#+BEGIN_SRC python
  def test_bool(self):
      assert_almost_equal(self.avg('marked'), .3, 1)
    
  def test_float(self):
      assert_almost_equal(self.avg('weight'), .5, 1)
    
  def test_int(self):
      g = self.avg('age')
      e = (18.0 + 65)/2
    
      assert_almost_equal(g/100, e/100, 1)
    
  def test_func(self):
      g = sum([abs(self.get_attribute('answer').count(c) - 333.33) / 1000.0
               for c in ['yes', 'no', 'maybe']])
    
      assert_less(g, .1)
#+END_SRC
**** Testing Functions and Generators
:PROPERTIES:
:noweb-ref: test functions and generators
:END:
The functions and generators are where the real generality (to an
extent) comes in.  We should be able to define a function that takes
one argument---a random number generator---and spits out values for
us.  In fact, we should be able to use a few things:
- a function that, given a random number generator, returns a value
- a function that, given a random number generator, returns a
  generator of values
- a raw generator of values.

#+BEGIN_SRC python
  def test_raw_func(self):
      choices = ['yes', 'no', 'maybe']
      def get_marked(random_instance):
          return random_instance.choice(choices)
      g = generators.random_graph(15, marked=get_marked)
      assert all(map(lambda n: g.node[n]['marked'] in choices, g.node))
  
  def test_lambda_func(self):
      choices = ['yes', 'no', 'maybe']
      g = generators.random_graph(15, marked=lambda r: r.choice(choices))
      assert all(map(lambda n: g.node[n]['marked'] in choices, g.node))
#+END_SRC
and now to test generators:
#+BEGIN_SRC python
  def test_generator_func(self):
      def gen_weight(random_instance):
          while True:
              yield random_instance.random()
      g = generators.random_graph(15, weight=gen_weight)
      assert all(map(lambda n: 0 <= g.node[n]['weight'] < 1, g.node))
  
  def test_generator_func2(self):
      def gen_in_range(minimum, maximum):
          # iter(int, True) is an infinite generator: 0, 0, 0, ...
          return lambda r: (r.uniform(minimum, maximum)
                            for i in iter(int, True))
  
      g = generators.random_graph(15, weight=gen_in_range(10, 20))
      assert all(map(lambda n: 10 <= g.node[n]['weight'] <= 20, g.node))
#+END_SRC
