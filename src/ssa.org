#+Title: Working with Self-Stabilizing Algorithms with Python
#+Author: Sean Allred
#+Date: [2013-12-24 Tue]

#+PROPERTY: noweb tangle
#+PROPERTY: mkdirp yes

* Notes
** Dijkstra 1974
A self-stabilizing network is seen as a graph of state machines.  Each
privilege is realized as a transition from the current state to
another state.  The state of the graph is passed as input to this
state machine.  When the input graph matches some predicate, this
privilege is set---there is some transition out of this state.  This
is why the choice of predicate to act upon is arbitrary: you can only
move to one other state!

When every node of the graph is in an accepting state with no set
predicates, then the graph has stabilized.

*** privilege
- we consider graphs of finite state machines
- privileges are boolean functions of the FSM's state and the states
  of its neighbors
- when these functions are true, the privilege is 'present'
*** system state
- each legitimate state must have at least one privilege present
  - even if the action is 'do nothing'
- in each legitimate state, every possible action will maintain
  legitimacy
- each privilege must be present in at least one legitimate state
- for any given pair of legitimate states, there exists a
  transformation between them
*** self-stabilization
regardless of the initial state and regardless of the privilege
selected each time for the next move, at least one privilege will
always be present and the system is guaranteed to find itself in a
legitimate state after a finite number of moves.


* Introduction
The project is set up as a [[http://learnpythonthehardway.org/book/ex46.html][traditional Python module]]:
#+BEGIN_EXAMPLE
  setup.py
  ssa/
      __init__.py
      core/
          __init__.py
      creation/
          __init__.py
      simulation/
          __init__.py
  bin/
  docs/
  tests/
      __init__.py
      core_tests.py
      creation_tests.py
      simulation_tests.py
#+END_EXAMPLE
#+BEGIN_SRC python :tangle "./setup.py"
  try:
      from setuptools import setup
  except ImportError:
      from distutils.core import setup
  
  config = {
      'description': 'A utility for the creation and evaluation of self-stabilizing algorithms',
      'author': 'Sean Allred',
      'url': 'http://github.com/vermiculus/smp',
      'download_url': 'http://github.com/vermiculus/smp',
      'author_email': 'seallred@smcm.edu',
      'version': '0.1',
      'install_requires': ['networkx', 'pygame'],
      'packages': ['ssa'],
      'scripts': [],
      'name': 'ssa'
  }
  
  setup(**config)
#+END_SRC
#+BEGIN_SRC python :tangle "ssa/__init__.py"
  import simulation
#+END_SRC
* [#A] Core Classes
#+BEGIN_SRC python "ssa/core/__init__.py"
  
#+END_SRC
In Dijkstra's 1974 paper, he describes a self-stabilizing algorithm as
a graph of state-machines:
#+BEGIN_QUOTE
We consider a connected graph in which the majority of the possible
edges are missing and a finite state machine is placed at each node;
machines placed in directly connected nodes are called each other's
neighbors.  For each machine one or more so-called "privileges" are
defined, i.e. boolean functions of its own state and the states of its
neighbors; when such a boolean function is true, we say that the
privilege is "present."  In order to model the undefined speed ratios
of the various machines, we introduce a central daemon---its
replacement by a distributed daemon falls outside the scope of this
article---that can "select" one of the privileges present.  The
machine enjoying the selected privilege will then make its "move";
i.e. it is brought into a new state that is a function of its old
state and the states of its neighbors.  If for such a machine more
than one privilege is present, the new state may also depend on the
privilege selected.  After completion of the move, the daemon will
select a new privilege.
#+END_QUOTE
Thus, we need to create a new class to act as the nodes of a NetworkX
graph.  This new node class will impose a collection of privileges
upon the object---privilege functions that must be additionally given
the collection of its neighbors.  These privilege functions do, of
course, return =True= or =False=.

Here comes the fun part: the new node class has a property (or rather,
a function =privileges_present=, TODO "python property act like a
function") that returns the identifications of all privileges that are
active---all those privileges of the node that return =True=---and
these identifications are then linked by a mapping within the node to
actions that they apply to.

** [#A] Dependencies
#+BEGIN_SRC python :tangle "ssa/core/__init__.py"
  from Action import Action
  from Privilege import Privilege
  from SelfStabilizingAlgorithm import SelfStabilizingAlgorithm
  from TeXableEntity import TeXableEntity
#+END_SRC
** Finite State Machine
#+BEGIN_SRC python 
  from ssa.core import TeXableEntity
  
  class FiniteStateMachine(TeXableEntity):
      <<initialization code>>
#+END_SRC

#+BEGIN_SRC python :noweb-ref "initialization code"
  pass
#+END_SRC
** [#C] TeXable Entity
Since this is all math and this research uses TeX almost exclusively,
it is worthwhile to include auto-generation of TeX documentation for
the algorithm.

A =TeXableEntity= is an object that has both human-readable
documentation and a TeX representation.  The documentation is what is
returned when the object is interpreted as a string, and the TeX
representation is the first part of the returned tuple when the object
is asked for its own representation.
#+BEGIN_SRC python :tangle "ssa/core/TeXableEntity.py"
  class TeXableEntity:
      def __init__(self, TeX=None, doc=None):
          self._TeX = TeX
          self._doc = doc
  
      def __repr__(self):
          return str((str(self._TeX), str(self._doc)))
  
      def __str__(self):
          return str(self._doc)
#+END_SRC
** [#A] Privileges and Actions
Privileges and Actions are very similar to each other.
*** TODO TeX-enabled predicates/actions
Create a class for =Predicate= and =Action= that both inherit from
=TeXableEntity=.  We should be able to attach TeX documentation to
rules and predicates so that we can have a nice display of the entity.

This could also be useful in export.
*** Privileges
#+BEGIN_SRC python :tangle "ssa/core/Privilege.py"
  class Privilege(TeXableEntity):
      """A function from G, v -> {True, False}
  
      >>> pred = Privilege(lambda G, v: v in G,
                           'G, v \mapsto v \in G',
                           'Returns true when $v$ is a node in $G$')
      >>> doc(pred)
      'Returns true when $v$ is a node in $G$'
      >>> repr(pred)
      'G, v \mapsto v \in G'
      """
      def __init__(self, predicate = lambda graph, node: True,
                         as_TeX    = None,
                         doc       = None):
          TeXableEntity.__init__(self, as_TeX, doc)
          self.predicate = predicate
  
      def __call__(self, graph, node):
          return self.predicate(graph, node)
  
      def __bool__(self, graph, node):
          return self()
#+END_SRC
**** TODO doctest callable
requires making a graph... ugh
*** Actions
#+BEGIN_SRC python :tangle "ssa/core/Action.py"
  class Action(TeXableEntity):
      """A function from G, v -> G'
  
      >>> action = Action(lambda G, v: v['marked'] = True,
                          'v.marked \gets True',
                          'Marks $v$')
      >>> doc(action)
      'Mark $v$'
      >>> repr(action)
      'v.marked \gets True'
      """
      def __init__(self, action = lambda graph, node: graph,
                         as_TeX = None,
                         doc    = None):
          TeXableEntity.__init__(self, as_TeX, doc)
          self.action = action
  
      def __call__(self, graph, node):
          return self.action(graph, node)
#+END_SRC
**** TODO doctest callable
** [#A] Self-Stabilizing Algorithm
- a dictionary from =Rule= objects to sets of =Privilege= objects.
- also a =TeXableEntity=

old code
#+BEGIN_SRC python :tangle "ssa/core/SelfStabilizingAlgorithm.py"
  """
  Base class for self-stabilizing algorithms.
  """
  
  __author__ = "Sean Allred (seallred@smcm.edu)"
  
  import networkx as nx
  import random
  
  class SelfStabilizingAlgorithm:
      """Base class for self-stabilizing algorithms.
  
      The SelfStabilizingAlgorithm class represents its namesake as a set
      of predicate-action pairs.
      """
      def __init__(self, rules=dict()):
          self.rules = rules
  
          for predicates in rules.keys():
              if not hasattr(predicates, '__getitem__'):
                  predicates = [predicates]
              for p in predicates:
                  self.add_rule(predicate, rules[predicate])
  
      def add_rule(self, predicate=lambda graph, privileged_node: True,
                         action=lambda graph, privileged_node: graph):
          """Add a rule to this algorithm.
  
          Parameters
          ----------
          predicate : f: (graph, node) \to {True, False}
          action :    f: (graph, node) \to graph
          """
          if predicate in self.rules:
              self.rules[predicate].append(action)
          else:
              self.rules[predicate] = [action]
  
      def apply_to(graph, count=1, keep_history=False):
          """Apply this algorithm to `graph` `count` times.
  
          Algorithm
          ---------
          Initialize this history and the current graph.  For as many
          times specified by `count`, do the following:
  
             1. Create a set of nodes that we need to check in this round,
                initialized to the complete set of nodes currently in the
                graph.
             2. While we have nodes to check,
                2.1 Randomly choose a privileged node from the set of
                    unchecked nodes.
                2.2 Create a set of all predicates that apply to the              # TODO: unnecessary to check them all
                    privileged node.
           ,*    2.3 If this set is not empty, choose a random predicate
                    from that set.  Otherwise, break out of the while
                    loop, leaving the matching predicate as a None-value
                    (see step 3).
                2.4 Remove this node from the set of unchecked nodes
           ,* 3. If the matching predicate is None, break.  There is no
                point in continuing to check since the state of the
                graph will no longer change.
             4. Retrieve the approriate action for the matching
                predicate.
             5. Update the current graph by applying the action
                appropriately.
             6. If we are keeping history, record the necessary elements
                and update the current graph to a deep copy of itself.
  
          (*) Represents a step where program flow may be redirected.
  
          Returns
          -------
          If `keep_history` is specified, the function will return a
          history (as a list of 3-tuples) that map the current state of
          the graph to the predicate and node that caused it.
          """
          history = [(graph, None, None)]
  
          if keep_history:
              current_graph = graph.copy()
          else:
              current_graph = graph
  
          for i in range(count):
              unchecked_nodes = current_graph.get_nodes()[:]
  
              privileged_node = None
              matching_predicate = None
  
              while unchecked_nodes:
                  privileged_node = random.choice(unchecked_nodes)
  
                  # I'm not using shuffle because "Note that for even
                  # rather small len(x), the total number of
                  # permutations of x is larger than the period of most
                  # random number generators; this implies that most
                  # permutations of a long sequence can never be
                  # generated."
                  preds = [p for p in self.rules.keys()]
                  while preds:
                      matching_predicate = random.choice(preds)
  
                      if p(current_graph, privileged_node):
                          break
  
                      preds.remove(matching_predicate)
  
                  unchecked_nodes.remove(privileged_node)
  
              if matching_predicate is None: break
              else:
                  matching_action = random.choice(self.rules[matching_predicate])
                  current_graph = matching_action(current_graph,
                                                  privileged_node)
  
                  if keep_history:
                      history.append((current_graph,
                                      matching_predicate,
                                      privileged_node))
                      current_graph = current_graph.copy()
  
          if keep_history:
              return history
          else:
              return graph
#+END_SRC
* [#B] Creation
  A graphical tool for the creation of self-stabilizing algorithms
#+BEGIN_SRC python :tangle "ssa/creation/__init__.py"

#+END_SRC
* [#B] Simulation
#+BEGIN_SRC python :tangle "ssa/simulation/__init__.py"
import generators
#+END_SRC
** Displaying a Graph
#+BEGIN_SRC python :tangle "ssa/simulation/glob.py"
  import pygame
  import networkx as nx
  
  pygame.init()
  
  class ColorBank:
      def __init__(self):
          self.black = (0, 0, 0)
          self.white = (255, 255, 255)
          self.red   = (255, 0, 0)
          self.green = (0, 255, 0)
          self.blue  = (0, 0, 255)
  
      def set_color(self, name, red, green, blue):
          setattr(self, str(name), (red, green, blue))
  
      @classmethod
      def get_inverse(cls, color, alpha=1):
          inverses = [255 - c for c in color] + [alpha]
          return tuple((channel for channel in inverses))
  
      @classmethod
      def random(cls, r):
          return tuple((r.randint(0, 255) for i in range(3)))
  
  class BasicNode:
      default_radius = 25
      default_color = (0,0,0)
      default_data = None
      default_position = (0, 0)
  
      def __init__(self, position=None,
                         radius=None,
                         color=None,
                         data=None,
                         randomize=None):
          if randomize is not None:
              r=randomize
              if data         is None: data       = '(random)'
              if color        is None: color      = ColorBank.random(r)
              if radius       is None: radius     = r.randint(3,50)
              if position     is None: position   = (r.random(), r.random())
          else:
              if data         is None: data       = BasicNode.default_data
              if color        is None: color      = BasicNode.default_color
              if radius       is None: radius     = BasicNode.default_radius
              if position     is None: position   = BasicNode.default_position
  
          if any(map(lambda c: not (0 <= c <= 1), position)):
              raise Exception('Woah there buddy.')
  
          self.data       = data
          self.color      = color
          self.radius     = radius
          self.position   = position
      def __str__(self):
          return str(self.data)
      def __repr__(self):
          return str(self.__dict__)
  
  class Visualizer:
      def __init__(self, size=(640, 480), graph=nx.Graph()):
          """where `size` is a 2-tuple representing screen dimens"""
  
          self.screen = pygame.display.set_mode(size)
  
          self.colors = ColorBank()
          self.graph = graph
          self.layout_algorithms = \
              [
              #nx.circular_layout,
              #nx.fruchterman_reingold_layout,
              #nx.graphviz_layout,
              #nx.pygraphviz_layout,
              #nx.random_layout,
              #nx.shell_layout,
              nx.spectral_layout,
              #nx.spring_layout
              ]
          # TODO sometimes crashes here; why?
          self.text_font = pygame.font.SysFont('monospace', 15)
  
      def do_layout(self, layout_algorithm=None):
          if layout_algorithm is None:
              layout_algorithm = random.Random().choice(self.layout_algorithms)
  
          p = layout_algorithm(self.graph)
  
          for node, position in zip(p.keys(), p.values()): # in p isn't working: iteration over non-sequence
              node.position = ((position[0] + 1) / 2, (position[1] + 1) / 2)
  
      def draw(self):
          self.screen.fill(self.colors.green)
          size = self.screen.get_size()
  
          for src, dst in self.graph.edges():
              pygame.draw.line(self.screen, self.colors.white,
                               self.floats_to_pos(src.position),
                               self.floats_to_pos(dst.position), 3)
  
          for n in self.graph.nodes():
              normal_pos = self.floats_to_pos(n.position) # keep track of z order for drag drop
              pygame.draw.circle(self.screen, n.color, normal_pos, n.radius, 0)
              label = self.text_font.render(str(n.data), True, ColorBank.get_inverse(n.color))
              self.screen.blit(label, normal_pos)
  
          pygame.display.update()
  
      def floats_to_pos(self, floats):
          return tuple((int(coordinate * scale) for coordinate, scale in zip(floats, self.screen.get_size())))
  
      def pos_to_floats(self, position):
          return tuple((coordinate / scale for coordinate, scale in zip(position, self.screen.get_size())))
  
      def loop(self):
          ingame=True
          while ingame:
              self.draw()
              pygame.time.delay(500)
              self.do_layout()
              for event in pygame.event.get():
                  if event.type == pygame.QUIT:
                      pygame.quit()
                      ingame = False
  
  if __name__ == '__main__':
      import random
      r = random.Random()
  
      screen_size = (640, 480)
  
      g = nx.Graph()
  
      for i in range(5):
          g.add_node(BasicNode(data=i, randomize=r))
  
      get_node=lambda i: filter(lambda n: n.data == i, g)
  
      import itertools
      for src, dst in itertools.combinations(g.nodes(), 2):
          if r.random() < .75:
              g.add_edge(src, dst)
  
      vis = Visualizer(size=screen_size, graph=g)
      vis.do_layout()
  
      vis.loop()
#+END_SRC
** Generating a Random Graph
#+BEGIN_SRC python :tangle "ssa/simulation/generators.py"
  import networkx
  import random
  
  from itertools import combinations
  
  class BasicNode:
      def __init__(self):
          pass
      def __repr__(self):
          return '{}::{}'.format(id(self), self.__dict__)
  
  def random_graph(degree, edge_probability=0.5, base_class=BasicNode, **properties):
      """Generates a random graph of `degree` nodes, a specified
      probability for edges, and a number of random properties.
  
      If `degree` is a tuple, it is assumed to be a (min, max) tuple
      defining an inclusive range of possible degrees.
  
      Each `properties` value can be a function of a random number
      generator.  If the value does not have __call__ defined, it will
      be assumed a string unless, as a string, it is one of the following:
  
      - 'int(n,m)': a random integer in [n, m]
      - 'float()' : a random floating point number in [0, 1)
      - 'bool(n)' : a random boolean with a probability of truth between
                    0 and 1 inclusive (where 1 is True).
  
      If the property value is neither callable nor a string of this
      form, then the value is simply set raw.
  
      Pass in a single argument, the degree of the graph, to get the
      bare-minimum graph (with a certain edge probability):
  
      >>> G = random_graph(50)
      >>> len(G.nodes())
      50
  
      Pass in a tuple to get a range of values:
  
      >>> G = random_graph((40, 60))
      >>> len(G.nodes()) in range(40, 60 + 1)
      True
  
      You can also use a few intelligent arguments, such as bool(n):
  
      >>> all(map(lambda n: n.marked,
      ...         random_graph(10, marked='bool(1)')))
      True
      >>> any(map(lambda n: n.marked,
      ...         random_graph(10, marked='bool(0)')))
      False
  
      float():
  
      >>> .45 < sum(map(lambda n: n.weight,
      ...         random_graph(1000, weight='float()')))/1000 < .55
      True
  
      and int(min, max):
  
      >>> all(map(lambda n: n.age in range(40, 50 + 1),
      ...         random_graph(10, age='int(40, 50)')))
      True
  
      Be careful about the arguments you pass.  If you want a range of
      possible values for the degree, ensure you pass an iterable of
      exactly two elements:
  
      >>> random_graph((1,2,3))
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      ValueError: Wrong number of values for (min, max) degree
  
      Mind the arguments for the keywords 'bool', 'int', and 'float'.
  
      >>> random_graph(5, marked='int(3,4,5)')
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      ValueError: Wrong number of arguments for int.
      """
      r = random.Random()
      G = networkx.Graph()
  
      if hasattr(degree, '__getitem__'):
          if len(degree) is not 2:
              raise ValueError('Wrong number of values for (min, max) degree')
          degree = r.randint(*degree)
  
      for n in range(degree):
          new_node = base_class()
  
          for key in properties:
              new_prop = str(key)
              new_value = properties[key]
              # Avoid overwriting properties.  This could happen if the
              # user passes in something that is a dictionary rather
              # than a traditional KV list.  We'll accept anything that
              # has __str__, but __str__ is not meant to be unique.
              if hasattr(new_node, new_prop): 
                  raise Exception('Did not overwrite duplicate property')
  
              if hasattr(properties[key], '__call__'):
                  setattr(new_node, new_prop, new_value(r))
              else:
                  if '(' in new_value and ')' in new_value: # val is a func
                      # collect the arguments
                      # TODO: make this safe, i.e. destroy `eval`
                      func = new_value[:new_value.index('(')]
                      args = eval(new_value[new_value.index('('):])
                      ex = lambda t: ValueError('Wrong number of arguments for {}.'.format(t))
  
                      if func == 'float':
                          if len(args) is not 0: raise ex('float')
                          new_value = r.random()
                      elif func == 'int':
                          if len(args) is not 2: raise ex('int')
                          new_value = r.randint(*args)
                      elif func == 'bool':
                          new_value = r.random() <= float(args)
  
                  setattr(new_node, new_prop, new_value)
          
          G.add_node(new_node)
  
      for src, dst in combinations(G.nodes(), 2):
          # perhaps add switch to check for __call__(node_a, node_b)
          if r.random() <= edge_probability:
              G.add_edge(src, dst)
      
      return G
  
  if __name__ == '__main__':
      import doctest
      doctest.testmod()
#+END_SRC
** [#B] On-screen animation
** [#C] Step-by-Step TeX printouts
* [#B] Tests
We will be using the Nose toolset for automated testing.
#+BEGIN_SRC python :noweb-ref "common imports for testing"
  import unittest
  from nose.tools import *
#+END_SRC
** Core
#+BEGIN_SRC python :tangle "tests/core_tests.py"

#+END_SRC
** Creation
#+BEGIN_SRC python :tangle "tests/creation_tests.py"

#+END_SRC
** Simulation
This test is structured as those above, with a few specializations.
Since the random graph generator does not (and should not) create
predictable or reproducible results, we must create a very large
random graph (1000 nodes) and then perform some analysis on that same
graph multiple times.  (Otherwise, the tests would hang on this
portion for some time.)

We import all those classes that we need to and define a testing class
to contain the random graph in the correct scope.  After we define a
few helper functions to look at only one attribute at a time, we then
make our assertions on what the results /should/ look like.
#+BEGIN_SRC python :tangle "tests/simulation_tests.py"
  <<common imports for testing>>

  from ssa.simulation import *
  
  class RandomGraphTest(unittest.TestCase):
      @classmethod
      def setupClass(cls):
          cls.G = \
          <<create random graph>>
  
      <<define helper functions>>
  
      <<test randomness>>
#+END_SRC

We create a random graph with the following properties:
- degree :: 1000
- edge probability :: 70%
- marked :: 30% chance of being marked
- answer :: equal chances of being 'yes', 'no', or 'maybe'
- weight :: a random real in [0, 1)
- age :: a random number between 18 and 65
#+BEGIN_SRC python :noweb-ref "create random graph"
  generators.random_graph(\
      1000, .7,
      marked='bool(.3)',
      answer=lambda r: r.choice(['yes', 'no', 'maybe']),
      weight='float()',
      age='int(18, 65)')
#+END_SRC

Now that we have a graph of a bunch of objects with randomized
attributes, we need a way to extract these attributes out of the
entire collection of nodes in the graph.  We define
=get_attribute(attr)= to construct a list of values:
#+BEGIN_LaTeX
  \[
  \text{$n$.attribute} \forall n \in G
  \]
#+END_LaTeX
and an averaging function to average numerical values:
#+BEGIN_LaTeX
  \[
  \frac{\sum_{n \in G}{\text{$n$.attribute}}}{|G|}
  \]
#+END_LaTeX
#+BEGIN_SRC python :noweb-ref "define helper functions"
  def get_attribute(self, attr):
      return map(lambda n: getattr(n, attr), self.G.nodes())

  def avg(self, attr):
      return float(sum(self.get_attribute(attr)))/len(self.G.nodes())
#+END_SRC

We are ready to implement our tests.  For =bool=, =float=, and =int=,
we test to make sure the average values we collect from the generated
graph match the theoretical averages (the ones we gave to target). For
the special =func= case, we do something a little fancier.

To test the =func= case, we count the occurances of each possible
=answer= and find its absolute variance from the theoretical value it
should have ($1000/3=333.\bar3$).  We then sum those variances and
ensure it is less than some (generous) threshold value.
#+BEGIN_SRC python :noweb-ref "test randomness"
  def test_bool(self):
      assert_almost_equal(self.avg('marked'), .3, 1)
    
  def test_float(self):
      assert_almost_equal(self.avg('weight'), .5, 1)
    
  def test_int(self):
      g = self.avg('age')
      e = (18.0 + 65)/2
    
      assert_almost_equal(g/100, e/100, 1)
    
  def test_func(self):
      g = sum([abs(self.get_attribute('answer').count(c) - 333.33) / 1000.0
               for c in ['yes', 'no', 'maybe']])
    
      assert_less(g, .1)
#+END_SRC

