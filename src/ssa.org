#+Title: Working with Self-Stabilizing Algorithms with Python
#+Author: Sean Allred
#+Date: [2013-12-24 Tue]

#+PROPERTY: noweb tangle

* Introduction
* [#A] Core Classes
** [#A] Dependencies
#+BEGIN_SRC python :tangle "ssa/core/__init__.py"
  <<import-libraries>>
#+END_SRC
** [#C] TeXable Entity
Since this is all math and this research uses TeX almost exclusively,
it is worthwhile to include auto-generation of TeX documentation for
the algorithm.

A =TeXableEntity= is an object that has both human-readable
documentation and a TeX representation.  The documentation is what is
returned when the object is interpreted as a string, and the TeX
representation is the first part of the returned tuple when the object
is asked for its own representation.
#+BEGIN_SRC python :tangle "ssa/core/TeXableEntity.py"
  class TeXableEntity:
      def __init__(self, TeX=None, doc=None):
          self._TeX = TeX
          self._doc = doc
  
      def __repr__(self):
          return str((str(self._TeX), str(self._doc)))
  
      def __str__(self):
          return str(self._doc)
#+END_SRC
** [#A] Privileges and Actions
Privileges and Actions are very similar to each other.
*** TODO TeX-enabled predicates/actions
Create a class for =Predicate= and =Action= that both inherit from
=TeXableEntity=.  We should be able to attach TeX documentation to
rules and predicates so that we can have a nice display of the entity.

This could also be useful in export.
*** Privileges
#+BEGIN_SRC python :tangle "ssa/core/Privilege.py"
  class Privilege(TeXableEntity):
      """A function from G, v -> {True, False}
  
      >>> pred = Privilege(lambda G, v: v in G,
                           'G, v \mapsto v \in G',
                           'Returns true when $v$ is a node in $G$')
      >>> doc(pred)
      'Returns true when $v$ is a node in $G$'
      >>> repr(pred)
      'G, v \mapsto v \in G'
      """
      def __init__(self, predicate = lambda graph, node: True,
                         as_TeX    = None,
                         doc       = None):
          TeXableEntity.__init__(self, as_TeX, doc)
          self.predicate = predicate
  
      def __call__(self, graph, node):
          return self.predicate(graph, node)
  
      def __bool__(self, graph, node):
          return self()
#+END_SRC
**** TODO doctest callable
requires making a graph... ugh
*** Actions
#+BEGIN_SRC python :tangle "ssa/core/Action.py"
  class Action(TeXableEntity):
      """A function from G, v -> G'
  
      >>> action = Action(lambda G, v: v['marked'] = True,
                          'v.marked \gets True',
                          'Marks $v$')
      >>> doc(action)
      'Mark $v$'
      >>> repr(action)
      'v.marked \gets True'
      """
      def __init__(self, action = lambda graph, node: graph,
                         as_TeX = None,
                         doc    = None):
          TeXableEntity.__init__(self, as_TeX, doc)
          self.action = action
  
      def __call__(self, graph, node):
          return self.action(graph, node)
#+END_SRC
**** TODO doctest callable
** [#A] Self-Stabilizing Algorithm
- a dictionary from =Rule= objects to sets of =Privilege= objects.
- also a =TeXableEntity=

old code
#+BEGIN_SRC python
  """
  Base class for self-stabilizing algorithms.
  """
  
  __author__ = "Sean Allred (seallred@smcm.edu)"
  
  import networkx as nx
  import random
  
  class SelfStabilizingAlgorithm:
      """Base class for self-stabilizing algorithms.
  
      The SelfStabilizingAlgorithm class represents its namesake as a set
      of predicate-action pairs.
      """
      def __init__(self, rules=dict()):
          self.rules = rules
  
          for predicates in rules.keys():
              if not hasattr(predicates, '__getitem__'):
                  predicates = [predicates]
              for p in predicates:
                  self.add_rule(predicate, rules[predicate])
  
      def add_rule(self, predicate=lambda graph, privileged_node: True,
                         action=lambda graph, privileged_node: graph):
          """Add a rule to this algorithm.
  
          Parameters
          ----------
          predicate : f: (graph, node) \to {True, False}
          action :    f: (graph, node) \to graph
          """
          if predicate in self.rules:
              self.rules[predicate].append(action)
          else:
              self.rules[predicate] = [action]
  
      def apply_to(graph, count=1, keep_history=False):
          """Apply this algorithm to `graph` `count` times.
  
          Algorithm
          ---------
          Initialize this history and the current graph.  For as many
          times specified by `count`, do the following:
  
             1. Create a set of nodes that we need to check in this round,
                initialized to the complete set of nodes currently in the
                graph. 
             2. While we have nodes to check,
                2.1 Randomly choose a privileged node from the set of
                    unchecked nodes.
                2.2 Create a set of all predicates that apply to the              # TODO: unnecessary to check them all
                    privileged node.
           ,*    2.3 If this set is not empty, choose a random predicate
                    from that set.  Otherwise, break out of the while
                    loop, leaving the matching predicate as a None-value
                    (see step 3).
                2.4 Remove this node from the set of unchecked nodes
           ,* 3. If the matching predicate is None, break.  There is no
                point in continuing to check since the state of the
                graph will no longer change.
             4. Retrieve the approriate action for the matching
                predicate.
             5. Update the current graph by applying the action
                appropriately.
             6. If we are keeping history, record the necessary elements
                and update the current graph to a deep copy of itself.
  
          (*) Represents a step where program flow may be redirected.
  
          Returns
          -------
          If `keep_history` is specified, the function will return a
          history (as a list of 3-tuples) that map the current state of
          the graph to the predicate and node that caused it.
          """
          history = [(graph, None, None)]
  
          if keep_history:
              current_graph = graph.copy()
          else:
              current_graph = graph
  
          for i in range(count):
              unchecked_nodes = current_graph.get_nodes()[:]
  
              privileged_node = None
              matching_predicate = None
  
              while unchecked_nodes:
                  privileged_node = random.choice(unchecked_nodes)
  
                  # I'm not using shuffle because "Note that for even
                  # rather small len(x), the total number of
                  # permutations of x is larger than the period of most
                  # random number generators; this implies that most
                  # permutations of a long sequence can never be
                  # generated."
                  preds = [p for p in self.rules.keys()]
                  while preds:
                      matching_predicate = random.choice(preds)
  
                      if p(current_graph, privileged_node):
                          break
  
                      preds.remove(matching_predicate)
  
                  unchecked_nodes.remove(privileged_node)
  
              if matching_predicate is None: break
              else:
                  matching_action = random.choice(self.rules[matching_predicate])
                  current_graph = matching_action(current_graph,
                                                  privileged_node)
  
                  if keep_history:
                      history.append((current_graph,
                                      matching_predicate,
                                      privileged_node))
                      current_graph = current_graph.copy()
  
          if keep_history:
              return history
          else:
              return graph
#+END_SRC
* [#B] Visualization
** [#B] On-screen animation
** [#C] Step-by-Step TeX printouts
* [#B] Testing
