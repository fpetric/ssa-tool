# -*- mode: org ; encoding: utf-8 -*-
#+Title: SSA-Tool

#+STARTUP: indent
#+PROPERTY: noweb tangle

#+TODO: TODO | DONE POSTPONED IDEA

* Introduction
:PROPERTIES:
:ID:       1A23DFC9-015C-4ADE-B684-18067EF90281
:END:
#+BEGIN_SRC python :tangle "odin.py"
  <<graphs>>
  <<fio>>
  <<core>>
  <<cli>>
  <<gui>>
  # Local Variables:
  # python-shell-interpreter: "python3"
  # truncate-lines: t
  # End:
#+END_SRC
** Noweb Prefixes
- =graphs= :: Graph Generation and Manipulation
- =core= :: Core Engine: Self-Stabilizing Algorithms
- =fio= :: File Input and Output
- =cli= :: Command Line Interface
- =gui= :: Graphical User Interface

* File Input and Output
:PROPERTIES:
:noweb-ref: fio
:END:

#+BEGIN_SRC python
  <<fio/selective yaml>>
  <<fio/bundle>>
#+END_SRC

** YAML
:PROPERTIES:
:noweb-ref: fio/selective yaml
:END:
#+BEGIN_SRC python
  import yaml
  class SelectiveYAMLObject(yaml.YAMLObject):
      hidden_fields = []
      @classmethod
      def to_yaml(cls, dumper, data):
          new_data = copy.deepcopy(data)
          for item in cls.hidden_fields:
              del new_data.__dict__[item]
          return dumper.represent_yaml_object(
              cls.yaml_tag, new_data,
              cls, flow_style=cls.yaml_flow_style)
#+END_SRC
** Bundles
:PROPERTIES:
:noweb-ref: fio/bundle
:END:

#+BEGIN_SRC python
  class Bundle:
      def __init__(self, initpath=None,
                   move_dir='moves', predicate_dir='predicates',
                   description_document='bundle.yaml'):

          self.entities             = set()
          self.move_dir             = move_dir
          self.predicate_dir        = predicate_dir
          self.description_document = description_document

          self.__len__      = self.entities.__len__
          self.__contains__ = self.entities.__contains__
          self.__iter__     = lambda s: iter(s.entities)
          self.__next__     = iter(self.entities).__next__

          if initpath is not None:
              self.load(initpath)

      def __len__(self):
          return len(self.entities)

      def __contains__(self, item):
          return self.entities.contains(item)

      def __iter__(self):
          self.__entity_iterator = iter(self.entities)
          return self.__entity_iterator

      def __next__(self):
          r = next(self.__entity_iterator)

      def load(self, path):
          fullpath = '{!s}/{!s}'.format(path, self.description_document)
          yaml_objects = list(yaml.load_all(open(fullpath, 'r')))
          [self.load_definition(path, obj) for obj in yaml_objects]
          for algorithm in yaml_objects:
              if hasattr(algorithm, 'resolve_rules'):
                  algorithm.resolve_rules(yaml_objects)
          self.entities.update(yaml_objects)

      def load_definition(self, path, ssa_obj):
          if hasattr(ssa_obj, 'filename'):
              tag   = ssa_obj.__class__.yaml_tag
              style = ssa_obj.__class__.yaml_flow_style

              # Create new class with inherited YAML attributes
              ssa_obj.__class__ = type(ssa_obj.__class__.__name__,
                                       (ssa_obj.__class__,),
                                       {
                                           'yaml_tag': tag,
                                           'yaml_flow_style': style
                                       })

              # Define call
              with open('/'.join([path, ssa_obj.ssa_folder, ssa_obj.filename])) as f:
                  lines = f.readlines()

              ssa_obj.definition = lines

              lines = ['def temp(self, v, N):\n'] + \
                      ['    ' + l for l in lines]
              exec("".join(lines), locals())
              ssa_obj.__class__.__call__ = locals()['temp']


      def sorted(self):
          return sorted(self.entities, reverse=True, key=lambda e: repr(e))

      def to_yaml(self):
          return yaml.dump_all(self.sorted(), explicit_start=True)

      def dump(self, path):
          # create path as directory
          import os
          os.makedirs(path, exist_ok=True)
          for subdir in [self.move_dir, self.predicate_dir]:
              os.makedirs('{!s}/{!s}'.format(path, subdir), exist_ok=True)
          # gather predicates and moves and set in directories
          predicates = []
          moves      = []
          algorithms = []
          for entity in self.entities:
              name = entity.__class__.__name__
              if   name ==      Move.__name__:      moves.append(entity)
              elif name == Predicate.__name__: predicates.append(entity)
              elif name == Algorithm.__name__: algorithms.append(entity)
              else: raise Exception('Encountered an invalid object: {!r}'.format(name))

          for p in predicates:
              with open('/'.join([path, self.predicate_dir, p.filename]), 'w') as f:
                  f.writelines(p.definition)

          for p in moves:
              with open('/'.join([path, self.move_dir, p.filename]), 'w') as f:
                  f.writelines(p.definition)

          for a in algorithms:
              a.simplify()

          yaml.dump_all(self.sorted(),
                        open('{}/{}'.format(path, self.description_document), 'w'),
                        explicit_start=True)

          for a in algorithms:
              a.resolve_rules(self.entities)

      def types(self, cls):
          for entity in self.entities:
              if isinstance(entity, cls):
                  yield entity
      def lookup(self, cls, name):
          hits = list()
          for entity in self.types(cls):
              if entity.name == name:
                  hits.append(entity)
          if not hits:
              return None
          elif len(hits) > 1:
              raise Exception('multiply defined names for {}."{}"'.format(cls.__name__, name))
          else:
              return hits[0]
#+END_SRC
* Self-Stabilizing Algorithms [2/3]
:PROPERTIES:
:noweb-ref: core
:END:
#+BEGIN_SRC python
  <<core/pm>>
  <<core/rule>>
  <<core/algorithm>>
#+END_SRC
** DONE Predicates and Moves
:PROPERTIES:
:noweb-ref: core/pm
:END:
#+BEGIN_SRC python
  class Predicate(SelectiveYAMLObject):
      yaml_tag = u'!Predicate'
      ssa_folder = 'predicates'
      <<core/pm/common>>

  class Move(SelectiveYAMLObject):
      yaml_tag = u'!Move'
      ssa_folder = 'moves'
      <<core/pm/common>>
#+END_SRC
#+BEGIN_SRC python :noweb-ref core/pm/common
  yaml_flow_style = False
  hidden_fields=['definition', '_run_func']

  def __init__(self, name, filename, description=None, author=None, date=None, tex=None):
      self.filename    = filename
      self.name        = name
      self.description = description
      self.author      = author
      self.date        = date
      self.tex         = tex

  def __repr__(self):
      return "{!s} '{!s}'".format(self.__class__.__name__.lower(), self.name)

  def __call__(self, vertex, neighborhood):
      assert hasattr(self, '_run_func') and self._run_func
      return self._run_func(vertex, neighborhood)
#+END_SRC
** DONE Rules
#+BEGIN_SRC python
  class Rule(yaml.YAMLObject):
      yaml_tag = u'!Rule'
      def __init__(self, predicate=None, moves=None, name=None, description=None, author=None, date=None):
          self.description = description
          self.author      = author
          self.date        = date
          self.predicate   = predicate
          self.moves       = moves
          self.name        = name

      def __repr__(self):
          return "rule '{!s}'".format(self.name)

      def applies_to(self, v, N):
          return bool(self.predicate(v, N))

      def apply_to(self, graph, node, r=random):
          move = r.choice(self.moves)

          move(graph.node[node], neighbor_data(graph, node))

          return Delta(changes={node: neighbor_data(graph, node)},
                       actor=move)
#+END_SRC
** TODO Algorithms
#+BEGIN_SRC python
  class Algorithm(yaml.YAMLObject):
      yaml_tag = u'!Algorithm'
      yaml_flow_style = False
      ssa_folder = None

      def __init__(self, name=None, author=None, date=None, rules=None):
          self.name   = name
          self.author = author
          self.date   = date
          self.rules  = rules

      def resolve_rules(self, entities):
          mapping = {entity.name if hasattr(entity, 'name') else repr(entity): entity
                     for entity in entities}
          for rule in self.rules:
              rule.predicate = mapping[rule.predicate]
              rule.moves = [mapping[m] for m in rule.moves]
      def simplify(self):
          '''undoes resolve_rules for saving'''
          for rule in self.rules:
              rule.predicate = rule.predicate.name
              rule.moves = [m.name for m in rule.moves]

      def run(self, graph, count=1):
          assert count >= 0
          anigraph = AnimatedGraph(graph)
          while count > 0:
              privileged_nodes = dict()
              for node in graph:
                  neighbors = neighbor_data(graph, node)
                  for rule in self.rules:
                      if rule.applies_to(graph.node[node], neighbors.values()):
                          if node in privileged_nodes:
                              privileged_nodes[node] += rule
                          else:
                              privileged_nodes[node] = [rule]
              if not privileged_nodes:
                  break
              node = random.choice(list(privileged_nodes.keys()))
              neighbors = neighbor_data(graph, node)
              applied_rule = random.choice(privileged_nodes[node])
              delta = rule.apply_to(graph, node)
              anigraph.deltas.append(delta)
              count -= 1
          return anigraph

      def has_stabilized(self, graph):
          for node in graph:
              neighbors = neighbor_data(graph, node)
              for rule in self.rules:
                  if rule.applies_to(graph.node[node], neighbors.values()):
                      return False
          return True

      def stabilize(self, graph):
          while not self.has_stabilized(graph):
              self.run(graph)

      def __repr__(self):
          return "{!s} '{!s}'".format(self.__class__.__name__.lower(), self.name)

      def lookup(self, name):
          for rule in self.rules:
              if rule.name == name:
                  return rule
#+END_SRC
* Graph Generation and Manipulation [3/3]
:PROPERTIES:
:noweb-ref: graphs
:END:

#+BEGIN_SRC python
  <<graphs/ani>>
  <<graphs/gen>>
  <<graphs/util>>
#+END_SRC

** DONE Animated Graphs [3/3]
:PROPERTIES:
:ID:       A037B209-3ECF-4752-AB0F-A52EB203AF42
:noweb-ref: graphs/ani
:END:
Set up similarly to GIF animations; only change what you need to change.
#+BEGIN_SRC python
  import networkx as nx
  import copy
  class AnimatedGraph:
      class Delta:
          <<graphs/ani/delta>>
      def __init__(self, graph, *deltas):
          self.base_graph = copy.deepcopy(graph)
          self.deltas = list(deltas)
      <<graphs/ani/implementation>>
#+END_SRC

*** DONE Implementation
:PROPERTIES:
:noweb-ref: graphs/ani/implementation
:ID:       8B53B97B-8F0C-48AC-A46C-10BC2A21DE53
:END:
#+BEGIN_SRC python
  def __iter__(self):
      graph = self.base()
      yield graph
      for delta in self.deltas:
          delta.apply_to(graph)
          yield graph
  def __getitem__(self, idx):
      current = 0
      track = iter(self)
      G = next(track)
      while current != idx:
          G = next(track)
          current += 1
      return G if G else self.base()
#+END_SRC
#+BEGIN_SRC python
  def __len__(self):
      return len(self.deltas)
  def base(self):
      return copy.deepcopy(self.base_graph)
  def __add__(self, other):
      assert other.base_graph == self.base_graph
      return AnimatedGraph(graph=self.base_graph,
                           deltas=self.deltas.extend(other.deltas))
#+END_SRC

*** DONE Deltas
:PROPERTIES:
:noweb-ref: graphs/ani/delta
:ID:       EE514D38-DF43-4BF5-BF4F-0882D8215461
:END:
#+BEGIN_SRC python
  def __init__(self, changes, actor=None):
      self.changes = changes
      self.actor = actor # the thing that brought about this delta
      """
      changes =>
      { 1: {'marked': True},
        3: {'marked': False} }
      """
  def apply_to(self, graph):
      assert all(lambda n: n in graph,
                 self.changes.keys())
      for node, properties in self.changes.items():
          for key, value in properties.items():
              graph.node[node][key] = value
#+END_SRC
*** POSTPONED Export
** DONE Generators [4/4]
:PROPERTIES:
:noweb-ref: graphs/gen
:ID:       7912B946-580B-4B70-9B2B-ACF8012FBDFC
:END:
#+BEGIN_SRC python
  import random
  import itertools
  import types
  class Generators:
      @staticmethod
      def random_graph(degree, edge_probability=0.5, factory=None, **properties):
          <<graphs/gen/random>>
      @staticmethod
      def sparse_graph(degree, extra_paths=None, factory=None, **properties):
          <<graphs/gen/sparse>>
      @staticmethod
      def broad_tree(degree, factory=None, breadth_factor=.5, **properties):
          <<graphs/gen/broad>>
      @staticmethod
      def deep_tree(degree, factory=None, **properties):
          <<graphs/gen/deep>>
#+END_SRC

*** DONE Random Graphs
:PROPERTIES:
:noweb-ref: graphs/gen/random
:ID:       C315D9D2-BE1C-447A-8961-4080AFD9B648
:END:
To thoroughly test graph algorithms (in lieu of or in preparation for
proof), it is very useful to have a means to create randomized graphs
with certain characteristics.  NetworkX has a few generators at its
disposal for creating graphs with deeper properties than I have
knowledge of, but the following function is able to create a random
graph with nodes having randomized properties.
#+BEGIN_SRC python
  """Generates a random graph of `degree` nodes, a specified
  probability for edges, and a number of random properties.

  <<graphs/gen/random/documentation>>
  """
  <<graphs/gen/random/ensure types>>
  <<graphs/gen/random/check if degree is range>>
  <<graphs/gen/random/check for dynamically-created generators>>
  for n in range(degree):
      <<graphs/gen/random/add node>>
  <<graphs/gen/random/add edges>>
  return G
#+END_SRC
**** Documentation
:PROPERTIES:
:noweb-ref: graphs/gen/random/documentation
:ID:       EA6DC1E5-538A-4371-A254-444B7145A4F4
:END:
#+BEGIN_SRC markdown
  <<graphs/gen/random/summary>>
  <<graphs/gen/random/basic usage>>
  <<graphs/gen/random/errors>>
#+END_SRC
***** Summary
:PROPERTIES:
:noweb-ref: graphs/gen/random/summary
:ID:       8B74D6F0-01A1-4F02-A72F-BCF638CAFA3A
:END:
#+BEGIN_SRC markdown
  If `degree` is a tuple, it is assumed to be a (min, max) tuple
  defining an inclusive range of possible degrees.
    
  Each `properties` value can be a function of a random number
  generator.  If the value does not have `__call__` defined, it will be
  assumed a string unless, as a string, it is one of the following:
    
  - 'int(n,m)' :: a random integer in [n, m]
  - 'float()'  :: a random floating point number in [0, 1)
  - 'bool(n)'  :: a random boolean with a probability of truth between 0
                  and 1 inclusive (where 1 is True).
    
  If the property value is neither callable nor a string of this form,
  then the value is simply set raw.
#+END_SRC
***** Basic Usage
:PROPERTIES:
:noweb-ref: graphs/gen/random/doctest basic usage
:ID:       B7DEB09C-A4BA-41E8-B0C3-FBE857CD3768
:END:
#+BEGIN_SRC markdown
  Pass in a single argument, the degree of the graph, to get the
  bare-minimum graph (with a certain edge probability):
    
      >>> G = random_graph(50)
      >>> len(G.nodes())
      50
  
  Pass in a tuple to get a range of values:
    
      >>> G = random_graph((40, 60))
      >>> len(G.nodes()) in range(40, 60 + 1)
      True
    
  You can also use a few intelligent arguments, such as bool(n):
  
      >>> G = random_graph(10, marked='bool(1)')
      >>> all(map(lambda n: G.node[n]['marked'], G.node))
      True
      >>> G = random_graph(10, marked='bool(0)')
      >>> any(map(lambda n: G.node[n]['marked'], G.node))
      False
    
  float():
  
      >>> G = random_graph(1000, weight='float()')
      >>> .45 < sum(map(lambda n: G.node[n]['weight'], G.node)) / 1000 < .55
      True
    
  and int(min, max):
    
      >>> G = random_graph(10, age='int(40, 50)')
      >>> all(map(lambda n: G.node[n]['age'] in range(40, 50 + 1), G.node))
      True
  
  For any attribute, you can specify a function or a generator.  You can
  even supply a function that *returns* a generator.  All functions must
  take exactly one required argument, a random number generator, as its
  first parameter.
  
  (ref:smp - optionify random thingy)
  
  Consider the following:
  
      >>> graph = random_graph(5, weight=(i for i in range(5)))
      >>> sorted([graph.node[n]['weight'] for n in graph.nodes()])
      [0, 1, 2, 3, 4]
  
                                                                           (ref:)
#+END_SRC

***** Possible Errors
:PROPERTIES:
:noweb-ref: graphs/gen/random/doctest errors
:ID:       7BABC0FD-E60F-482F-881F-1D666178A53F
:END:
#+BEGIN_SRC markdown
  Be careful about the arguments you pass.  If you want a range of
  possible values for the degree, ensure you pass an iterable of exactly
  two elements.
    
      >>> random_graph((1,2,3))
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      ValueError: Wrong number of values for (min, max) degree
    
  Mind the arguments for the keywords 'bool', 'int', and 'float'.
    
      >>> random_graph(5, marked='int(3,4,5)')
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      ValueError: Wrong number of arguments for int.
  
  If you are using generators, keep in mind that *each* node must be
  given a value.  If the generator produces less values than you give
  the graph nodes, an exception will be raised:
  
      >>> n = 5
      >>> g = random_graph(n + 1, weight=(i for i in range(n)))
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      Exception: Ran out of iterations for the generator given by 'weight'
#+END_SRC
**** Code
***** Type Checking
:PROPERTIES:
:noweb-ref: graphs/gen/random/ensure types
:ID:       1D75116D-4891-4DCB-86E0-AC45591AD245
:END:
#+BEGIN_SRC python
  r = random.Random()
  G = nx.Graph()
  if factory is None:
      def naturals():
          i = 0
          while True:
              yield i
              i += 1
      factory = naturals()
  assert hasattr(factory, '__next__')
#+END_SRC
***** Check Degree
:PROPERTIES:
:noweb-ref: graphs/gen/random/check if degree is range
:ID:       7FECCB59-E127-4732-9040-4E3751124122
:END:
#+BEGIN_SRC python
  if hasattr(degree, '__getitem__'):
      if len(degree) is not 2:
          raise ValueError('Wrong number of values for (min, max) degree')
      degree = r.randint(*degree)
#+END_SRC
***** Check for Dynamic Generators
:PROPERTIES:
:noweb-ref: graphs/gen/random/check for dynamically-created generators
:ID:       7BC11AE8-2368-406A-8328-ED4899AB62F4
:END:
In playing with the tool for a while, I've come to see a few use cases
for the ability to create 'on the fly' generators with lambda
expressions.  The code currently checks for functions by checking if
they define =__call__=, and this is good behavior.  However, it is
possible that such a function could return a generator object, so we
need to run through each property /first/ to check if calling any
existing functions yields a generator (no pun intended).
#+BEGIN_SRC python
  for key in properties:                  
      if hasattr(properties[key], '__call__'):
          check_value = properties[key](r)
          if isinstance(check_value, types.GeneratorType):
              properties[key] = check_value
#+END_SRC
***** Adding Nodes
:PROPERTIES:
:noweb-ref: graphs/gen/random/add node
:ID:       55DB7E3C-1E8B-46CE-A152-7E2A6F3169DD
:END:
#+BEGIN_SRC python
  new_node = next(factory)
  G.add_node(new_node)
  for key in properties:
      property_key = str(key)
      property_value = properties[key]
      <<graphs/gen/random/check for property overwrite>>
      <<graphs/gen/random/parse and set property value>>
#+END_SRC
****** Property Overwrite
:PROPERTIES:
:noweb-ref: graphs/gen/random/check for property overwrite
:ID:       3EAF3EE2-1960-455C-99B6-E7565E117359
:END:
#+BEGIN_SRC python
  # Avoid overwriting properties.  This could happen if the
  # user passes in something that is a dictionary rather
  # than a traditional KV list.  We'll accept anything that
  # has __str__, but __str__ is not meant to be unique.
  if hasattr(new_node, property_key): 
      raise Exception('Did not overwrite duplicate property')
#+END_SRC
****** Property Set
:PROPERTIES:
:noweb-ref: graphs/gen/random/parse and set property value
:ID:       D47028B9-01B3-42A6-AE7D-D6A4A7EB6C21
:END:
The new value can be a couple things.  If it is a callable function
(implements =__call__=), we assume it is some function that expects a
=random.Random= object as its single required parameter.  If it is a
generator (implements =next=), we retrieve the next value.  Otherwise,
we parse =property_value= as a string
#+BEGIN_SRC python
  new_value = None
  if hasattr(property_value, '__call__'):
      new_value = property_value(r)
  elif isinstance(property_value, types.GeneratorType):
      try:
          new_value = next(property_value)
      except StopIteration:
          raise Exception('Ran out of iterations for the generator given by {!r}'\
                              .format(property_key))
  elif '(' in property_value and ')' in property_value: # val is a func
      func = property_value[:property_value.index('(')]
      args = eval(property_value[property_value.index('('):])
      ex = lambda t: ValueError('Wrong number of arguments for {}.'.format(t))
      if func == 'float':
          if len(args) is not 0: raise ex('float')
          new_value = r.random()
      elif func == 'int':
          if len(args) is not 2: raise ex('int')
          new_value = r.randint(*args)
      elif func == 'bool':
          new_value = r.random() <= float(args)
  else:
      new_value = property_value
  G.node[new_node][property_key] = new_value
#+END_SRC
******* TODO Enhance security
We have the line =args=eval(property_value[...])=.  This should be
fine given the audience, but it is terribly unsafe.  Find a better way.

Perhaps we can represent arguments as tuples, LISP-style?
#+BEGIN_EXAMPLE
  random_graph(15,
    marked = ('bool', .3)
    weight = ('float',)
    ranged = ('float', 5, 7)
    more_r = ('range', 1, 10))
#+END_EXAMPLE
with =range= taking place of =int(...)=.
***** Adding Edges
:PROPERTIES:
:noweb-ref: graphs/gen/random/add edges
:ID:       36B4C2F6-1310-44CB-8936-1D282A666619
:END:
#+BEGIN_SRC python
  for src, dst in itertools.combinations(G.nodes(), 2):
      if r.random() <= edge_probability:
          G.add_edge(src, dst)
#+END_SRC
****** TODO perhaps
add switch to check for __call__(node_a, node_b) to determine
probability

*** DONE Sparse Graphs
:PROPERTIES:
:noweb-ref: graphs/gen/sparse
:END:
#+BEGIN_SRC python
  G = Generators.deep_tree(degree=degree, factory=factory, **properties)
  if extra_paths is None:
      extra_paths = int(degree * 1.5)
  for i in range(extra_paths):
      to_connect = random.sample(G.nodes(), 2)
      G.add_edge(*to_connect)
  return G
#+END_SRC
*** DONE Deep Trees
:PROPERTIES:
:noweb-ref: graphs/gen/deep
:END:
#+BEGIN_SRC python
  G = Generators.random_graph(degree=degree, edge_probability=0, factory=factory, **properties)
  while not nx.is_connected(G):
      to_connect = random.sample(nx.connected_components(G), 2)
      u = random.choice(to_connect[0])
      v = random.choice(to_connect[1])
      G.add_edge(u, v)
  return G
#+END_SRC

*** POSTPONED Broad Trees
:PROPERTIES:
:ID:       F582A16B-6C32-4C18-AC54-A71E4EDA1B0E
:noweb-ref: graphs/gen/broad
:END:
#+BEGIN_SRC python
  G = random_graph(degree=degree, edge_probability=0, factory=factory, **properties)
  while not nx.is_connected(G):
      nodes = G.nodes()
      root = random.choice(nodes)
      nodes.remove(root)
      children = list()
      while nodes:
          n = nodes.pop()
          if random.random() > breadth_factor:
              children.push(n)
      to_connect = random.sample(nx.connected_components(G), 2)
      u = random.choice(to_connect[0])
      v = random.choice(to_connect[1])
      G.add_edge(u, v)
  return G
#+END_SRC

** DONE Utility Functions [1/1]
:PROPERTIES:
:noweb-ref: graphs/util
:END:
*** DONE Getting Data from Neighbors
This function returns a mapping from vertices to their data for every
vertex =v= in the neighborhood of =node=.
#+BEGIN_SRC python
  def neighbor_data(graph, node):
      return {v: graph.node[v]
              for v in graph.neighbors(node)}
#+END_SRC

* Command Line Interface
:PROPERTIES:
:noweb-ref: cli
:END:

#+BEGIN_SRC python
  pass # cli
#+END_SRC

** Bundling

** Testing

* Graphical User Interface
:PROPERTIES:
:noweb-ref: gui
:END:

#+BEGIN_SRC python
  <<gui/test>>
#+END_SRC

** Predicate / Move Creation

** Rule Creation

** Algorithm Assembly

** Testing
:PROPERTIES:
:noweb-ref: gui/test
:END:
#+BEGIN_SRC python
  <<gui/test/vis>>
#+END_SRC
*** Graph Visualization
:PROPERTIES:
:noweb-ref: gui/test/vis
:END:
#+BEGIN_SRC python
  <<gui/test/vis/basic>>
  <<gui/test/vis/draggable>>
  <<gui/test/vis/animated>>
#+END_SRC
**** Basic Grapher
:PROPERTIES:
:noweb-ref: gui/test/vis/basic
:END:
#+BEGIN_SRC python
  import tkinter as tk

  class Grapher(tk.Canvas):
      def __init__(self, master,
                   graph            = None,
                   layout_algorithm = None,
                   node_painter     = None,
                   edge_painter     = None, *args, **kwargs):
          tk.Canvas.__init__(self, master, *args, **kwargs)

          <<gui/test/vis/basic/initialization>>

      def paint(self, padx=15, pady=15, do_layout=True):
          <<gui/test/vis/basic/painting the graph>>

      <<gui/test/vis/basic/customization>>

      <<gui/test/vis/basic/presets>>
#+END_SRC

***** Introduction and Usage
:PROPERTIES:
:ID:       B29429F4-F571-44D9-88EF-292A64E11412
:noweb-ref: null
:tangle:   no
:END:
For any graphical interface that aspires to be what SSA Tool is, a
means to actually view a more-or-less interactive graph on-screen is
invaluable.  In this document, we explore the creation of such a tool.

Manifested as a subclass of the =Canvas= widget in Tkinter, =Grapher=
will paint any NetworkX-style graph according to a given layout
algorithm and customizable node/edge-painting functions.  Usage is
pretty simple:
#+BEGIN_SRC python
  import networkx as nx
  import tkinter as tk
  from ssa import Grapher

  simple = tk.Tk()

  grapher = Grapher(simple)

  graph = nx.hypercube_graph(4)

  grapher.set_layout_algorithm(nx.random_layout)
  grapher.set_graph(graph)

  grapher.pack()
  grapher.paint()
#+END_SRC
****** Dependencies
The only hard-and-fast dependency of this component is,
unsurprisingly, Tkinter.  Given that this project as a whole can't
hope to implement all of even the most common layout algorithms,
NetworkX layout algorithms are used throughout this documentation in
the examples, but /they are not required to use the widget/.  Each and
every one of these layout algorithms require the =numpy= module, so it
is recommended that this is installed if you plan to use the
=networkx= module.  =Grapher= is designed to work with the format it
uses.  (See the section on [[id:7DC6B787-4AE5-45FF-9D78-8ABE8FD3E38F][layout algorithms]] for more information.)
****** A More Complex Example
:PROPERTIES:
:noweb-ref: null
:tangle:   "complex-grapher-example.py"
:ID:       62F7E10E-8C86-498C-9826-44BB105DE175
:END:
This example shows a window with a =Grapher= and a button which, when
pressed, will create a new sparse graph of increasing size.
#+BEGIN_SRC python
  import tkinter as tk
  import networkx as nx
  from odin import *

  def on_reconfigure(event):
      grapher.paint(do_layout=not bool(grapher.layout))

  def new_graph():
      global n
      n += 1
      grapher.set_graph(Generators.sparse_graph(n, marked='bool(.25)'))
      grapher.paint()

  n = 5

  root = tk.Tk()
  grapher = Grapher(root,
                    layout_algorithm=nx.circular_layout,
                    node_painter=Grapher.circle_node_painter,
                    background='#dddddd')
  tk.Button(root, text='New Graph', command=new_graph).pack()

  grapher.pack(fill = 'both', expand = True)

  root.bind('<Configure>', on_reconfigure)

  new_graph()

  root.mainloop()
  exit()
#+END_SRC
***** Overview
****** Initialization
:PROPERTIES:
:noweb-ref: gui/test/vis/basic/initialization
:ID:       2B46B8B6-C886-4411-B1AA-52D9890240DA
:END:
As you'll recall from the overview above, the constructor takes four
arguments aside from those related directly to Tkinter:
- =graph= :: a NetworkX-style graph.
- =layout_algorithm= :: a function from NetworkX-style graphs to
     layout dictionaries.  (This format is discussed in [[id:7DC6B787-4AE5-45FF-9D78-8ABE8FD3E38F][Layout
     Algorithms]].)
- =node_painter= :: a function to paint a node onto the canvas.  See
                    [[id:839E1EA2-74A4-4EB1-A79A-54FA6E7A1A51][Node Painters]].
- =edge_painter= :: a function to paint an edge onto the canvas.  See
                    [[id:25FE8932-BFB7-4F36-AEF3-DA58C6634FBE][Edge Painters]].

Since Python evaluates the default arguments at interpretation time
rather than use-time, we cannot give appropriate default values.  To
compensate, we set their default values to =None= and then check to
see if they need to be given the appropriate defaults.
#+BEGIN_SRC python
  if layout_algorithm is None:
      layout_algorithm = lambda G: \
                         {n: (0, 0) for n in G.nodes()}
  if node_painter is None:
      node_painter = Grapher.plain_node_painter
  if edge_painter is None:
      edge_painter = Grapher.plain_edge_painter
#+END_SRC
You'll notice that =graph= is not handled so; this case is handled
specially by =paint=.  This decision was made to make this file as
lean as possible---setting a reasonable default for this value would
necessitate importing the NetworkX graph manipulation library.

Using the setter functions defined in [[id:E4FB92BE-FD81-4716-8B23-EA63352114F3][Customization]], we use these
constructor arguments to set the appropriate settings.
#+BEGIN_SRC python
  self.set_graph(graph)
  self.set_layout_algorithm(layout_algorithm)
  self.set_node_painter(node_painter)
  self.set_edge_painter(edge_painter)
#+END_SRC

****** Layout Algorithms
:PROPERTIES:
:ID:       7DC6B787-4AE5-45FF-9D78-8ABE8FD3E38F
:noweb-ref: null
:tangle:   no
:END:
Along with the painters, layout algorithms are at the core of this
widget.  Without them, the widget has no hope of success.  Due to
their varying complexity and ready availability, this widget doesn't
attempt to provide such algorithms as part of the structure.  Thus,
there is no useful default.  (There is a default to ensure
non-crashing behavior with a minimalistic use, but it simply maps all
nodes to =(0, 0)=.)

So how does this tool expect these layout algorithms to act?  NetworkX
provides [[http://networkx.lanl.gov/reference/drawing.html#module-networkx.drawing.layout][several layout algorithms]] already (which unfortunately
require =numpy= as a dependency), so this widget is designed to use
the output of these algorithms.  These layout algorithms return a very
simple and sensible structure.
#+BEGIN_SRC python
  {
    node: (x, y),
    ...
  }
#+END_SRC
As a dictionary of x--y coordinates indexed by node, you can actually
use any Python structure that mimics such access.
#+BEGIN_SRC python
  coordinates = layout[node]
  x = coordinates[0]
  y = coordinates[1]
#+END_SRC

Actually providing these layout algorithms is left up to the user of
this widget.  Since it has nothing directly to do with really
/painting/ the graph, it has no particular business in this class.

****** Node and Edge Painters
:PROPERTIES:
:ID:       839E1EA2-74A4-4EB1-A79A-54FA6E7A1A51
:noweb-ref: null
:tangle:   no
:END:
One of the great strengths of this widget is its ability to be
customized.  Graphs are capable of holding a lot of data---anything
can have properties associated with it that this widget has little
hope of anticipating.  This was recognized from the start---the
customization of these painters is fully supported.

However, there are a couple things that are worth noting about these
painters---not the least of which is the signature each painter should
have:
#+BEGIN_SRC python
  def my_node_painter(canvas, layout, graph, node):
      # paint the node onto the canvas
  def my_edge_painter(canvas, layout, graph, source, sink):
      # paint the edge onto the canvas
#+END_SRC
A lot of responsibility is given to these functions, and perhaps this
responsibility should be mitigated.  (See the [[id:DED5600A-3B04-4C03-BA79-76ECBB3001BB]['todo' item]] below.)

See the [[id:8F3C5154-5DD4-495C-BA63-475CF2047455][basic painters]] below to see full, minimal examples of this.  If
you're unfamiliar with NetworkX's ability to store node data, you
should check out [[id:59724273-7AA1-42B6-9880-B0DEB3261C07][the example of that below]] as well.

******* TODO Simplify Painting
:PROPERTIES:
:ID:       DED5600A-3B04-4C03-BA79-76ECBB3001BB
:END:
Right now, customized painting leaves a lot of responsibility to the
widget user.  It could potentially be simplified by returning a
dictionary of attributes to use instead and then using this to
interface directly with the canvas.

In any case, a separate function should provide this interface in
order to preserve the raw power of the existing behavior.

***** Painting the Graph
:PROPERTIES:
:noweb-ref: gui/test/vis/basic/painting the graph
:END:
****** Preliminary Checks
:PROPERTIES:
:ID:       0E9E8D58-0736-403D-A22D-58C5FA0BE1F1
:END:
Before we proceed, we need to see if we have everything we need to
paint the graph.  There are two basic components that we need to
actually paint the graph.  If we have no =graph= to paint, well,
hopefully the problem here is obvious.  If we must lay out the graph
and have no =layout_algorithm=, then we have no way of determining the
positions of a given node within a graph.  The same applies if we must
/not/ lay out the graph and have no existing positions to use.  We do
some very simple (and incomprehensive) preliminary checks to avoid
running into problems down the line.
#+BEGIN_SRC python
  if self.graph is None:
      raise Exception('No graph specified.')
  if do_layout and self.layout_algorithm is None:
      raise Exception('No layout algorithm specified.')
  if not do_layout and self.layout is None:
      raise Exception('Re-layout prohibited and no existing layout in place.')
#+END_SRC

Additionally, =layout_algorithm= must be a function (or at least,
Pythonically speaking, /act/ like one).  We further check to see if
the member is callable as a function.
#+BEGIN_SRC python
  if not callable(self.layout_algorithm):
      raise Exception('Layout algorithm must be callable.')
#+END_SRC

****** Preparing to Paint
:PROPERTIES:
:ID:       DFADA623-F79E-40F5-9A2D-C8953019D8DB
:END:
To paint a clear picture, we first must remove all of the objects that
we've (potentially) already painted.  We can delete all of these like
as below.
#+BEGIN_SRC python
  self.delete(tk.ALL)
#+END_SRC

To get the node layout, there are actually a few steps we have to
take.  Before we do anything, we need to determine the current
dimensions of the widget.
#+BEGIN_SRC python
  wd = self.winfo_width()
  dp = self.winfo_height()
#+END_SRC
(Note that =wd= and =dp= are abbreviation for width and depth.)

If we were asked to recalculate the layout (the default), then we
reset =layout= to the results of a fresh run of the
=layout_algorithm= on =graph=.  Using =wd= and =dp= calculated above,
we then normalize =layout= to account for the current dimensions of
the width, using =padx= and =pady= appropriately.
#+BEGIN_SRC python
  if do_layout:
      self.layout = self.layout_algorithm(self.graph)

  normalized_layout = {node: (self.layout[node][0] * (wd - 2*padx) + padx,
                              self.layout[node][1] * (dp - 2*pady) + pady)
                       for node in self.layout}
#+END_SRC
Do recall that =layout= is kept as a dictionary from nodes to
coordinate pairs =(x, y)= where both /x/ and /y/ are kept in the range
[0, 1].  These values indicate their relative positions on the canvas;
=0= indicates the far left (or top) where =1= indicates the far right
(or bottom).  These values are scaled to the current width and depth
of the widget while with the padding specified by =padx= and =pady=.

******* TODO Zooming
It would be nice to have the ability to zoom.  Subclass, subclass,
subclass!
****** Painting
:PROPERTIES:
:ID:       3CFCD2FB-8B82-4F0E-95E6-83B687ABB24E
:END:
#+BEGIN_SRC python
  for edge in self.graph.edges():
      self.paint_edge(normalized_layout, self.graph, *edge)
  for node in self.graph.nodes():
      self.paint_node(normalized_layout, self.graph, node)
#+END_SRC
***** Customization
:PROPERTIES:
:noweb-ref: gui/test/vis/basic/customization
:ID:       E4FB92BE-FD81-4716-8B23-EA63352114F3
:END:
****** Graph
:PROPERTIES:
:ID:       FCAD87CF-8016-4644-8EA6-D09FDE35F1A7
:END:
#+BEGIN_SRC python
  def set_graph(self, graph):
      """Ensures `graph` is in the appropriate format and stores it"""
      self.graph = graph
#+END_SRC

****** Layout Algorithm
:PROPERTIES:
:ID:       DF682122-82C5-4DFD-8E7B-EEAD63B72FB2
:END:
#+BEGIN_SRC python
  def set_layout_algorithm(self, layout_algorithm):
      assert callable(layout_algorithm)
      self.layout_algorithm = layout_algorithm
#+END_SRC

****** Node Painting
:PROPERTIES:
:ID:       C148017D-374D-4788-9E7B-812D85B5636F
:END:
#+BEGIN_SRC python
  def set_node_painter(self, node_painter):
      self.paint_node = lambda layout, graph, node: \
                        node_painter(self, layout, graph, node)
#+END_SRC
When creating functions that are generally useful (say, [[id:0B00DABF-26A1-49CC-A37C-5E011BAE4BB4][a circle with
variable radius]]), you have to create them as functions that take these
variable values (e.g. =radius=) and returns a function that uses these
values.

****** Edge Painting
:PROPERTIES:
:ID:       B4859C46-99B6-47A4-ABC2-E0A6CDA78A0F
:END:
#+BEGIN_SRC python
  def set_edge_painter(self, edge_painter):
      self.paint_edge = lambda layout, graph, source, sink: \
                        edge_painter(self, layout, graph, source, sink)
#+END_SRC
***** Presets
:PROPERTIES:
:noweb-ref: gui/test/vis/basic/presets
:END:
****** Plain
:PROPERTIES:
:ID:       8F3C5154-5DD4-495C-BA63-475CF2047455
:END:
You can refer to the following as minimal examples for how to define
these functions.  As simple as they are, they are of limited practical
use.

The following function simply draws the string representation of the
node at the position specified by =layout=.
#+BEGIN_SRC python
  @staticmethod
  def plain_node_painter(canvas, layout, graph, node):
      canvas.create_text((layout[node][0], layout[node][1]), text=str(node))
#+END_SRC

The following function draws an edge from =source= to =sink=.
#+BEGIN_SRC python
  @staticmethod
  def plain_edge_painter(canvas, layout, graph, source, sink):
      canvas.create_line(layout[source][0],    layout[source][1],
                         layout[sink]  [0],    layout[sink]  [1],
                         width=1.0)
#+END_SRC

****** Circle
:PROPERTIES:
:ID:       0B00DABF-26A1-49CC-A37C-5E011BAE4BB4
:END:
The following node painter will draw a node as a white circle with
black text.  This text is simply the string representation of the
given =node=.
#+BEGIN_SRC python
  @staticmethod
  def circle_node_painter(canvas, layout, graph, node):
      r = 10
      x = layout[node][0]
      y = layout[node][1]
      canvas.create_oval((x-r, y-r, x+r, y+r), fill='white', tags='node')
      canvas.create_text((x, y), text=str(node), tags='node')
#+END_SRC

****** TODO Rectangle
This option is yet to be implemented.

***** Full Example
:PROPERTIES:
:ID:       59724273-7AA1-42B6-9880-B0DEB3261C07
:END:
#+BEGIN_SRC python :tangle "example.py" :noweb-ref nil
  import networkx as nx
  import tkinter as tk
  from odin import *

  from ssa import Grapher

  def new_graph():
      gen.reset_basic_node_counter()
      grapher.set_graph(Generators.sparse_graph(10, marked='bool(.5)'))
      grapher.paint()

  def marked_node_painter(canvas, layout, graph, node):
          r = 10
          x = layout[node][0]
          y = layout[node][1]
          canvas.create_oval((x-r, y-r, x+r, y+r),
                             fill='black' if graph.node[node]['marked'] else 'white',
                             tags='node')
          canvas.create_text((x, y), text=str(node),
                             fill='white' if graph.node[node]['marked'] else 'black',
                             tags='node')

  root = tk.Tk()

  root.title('Graph Painter 4000')

  grapher = Grapher(root, width=400, height=300, background='gray')
  grapher.pack()
  grapher.set_layout_algorithm(nx.circular_layout)
  grapher.set_node_painter(marked_node_painter)

  new_graph()

  tk.Button(root, text='New Graph', command=new_graph).pack()
#+END_SRC
***** TODO Draggable nodes
Since the canvas is just a collection of items, we can add event
handlers for all nodes via the use of tags.  As good as layout
algorithms are, everybody likes their own setup.

In order to keep class as simple as possible, perhaps this should be
implemented in a separate subclass.  Given that Python supports
multiple inheritance (to a point; there are of course
obvious language-agnostic concerns), we could then just combine this
with the animated subclass.
***** TODO Postscript Export
We can leverage =tk.Canvas.postscript= to support Postscript export.
This would perhaps be very valuable to TeX export.
**** Draggable Grapher
**** Animated Grapher
We now have a means of drawing a graph on-screen in an easy-to-use
Tkinter widget.  We can paint the graph, change the graph, and repaint
it effortlessly.  While it is straightforward to do this, it can get
repetitive.  In their essence, self-stabilizing algorithms operate on
graphs and change them /continuously/; to see this change, this
paint--repaint sequence must be executed over and over again while
going at a slow enough pace to actually /see/ the change.  Clearly,
there is enough functionality here to encapsulate it in a separate
=GraphAnimator= class as a subclass of =Grapher=.

The primary thought behind this implementation stems from the natural
sequence of steps that a self-stabilizing algorithm---or, in fairness,
/any/ animation---produces.  =GraphAnimator= uses the paradigm of
stop-motion animation by storing a queue of graphs (or as we shall
see, a much more compact queue of changes deltas) and painting them
one after another at specified intervals.

***** Definition
:PROPERTIES:
:ID:       02B822BC-5430-443F-8C02-08C8154CCD18
:noweb-ref: gui/test/vis/animated
:END:
We subclass =Grapher= and a single instance variable:
- =interval= :: the time, in seconds, between steps of the animation
To separate the functionality into the logical concept of an 'animated
graph' and a 'graph animator', we will be creating two classes
- =AnimatedGraph= :: a new class that operates on a NetworkX graph and
     provides logic to generate successive graphs through a series of
     deltas.
- =GraphAnimator= :: a subclass of =Grapher= to display objects of
     type =AnimatedGraph=
We then define logic for queueing these steps and then finally logic
for performing the actual animation.
#+BEGIN_SRC python
  import threading
  import collections

  class GraphAnimator(Grapher):
      def __init__(self, master, interval=1, *args, **kwargs):
          Grapher.__init__(self, master, *args, **kwargs)
          self.interval = interval

      <<gui/test/vis/animated/queueing graphs>>
      <<gui/test/vis/animated/animating>>
#+END_SRC

***** Queueing Data for Animation
:PROPERTIES:
:noweb-ref: gui/test/vis/animated/queueing graphs
:END:
#+BEGIN_SRC python
  def load(self, queue):
      self.queue.extend(queue)
#+END_SRC
  
#+BEGIN_SRC python
  def isdelta(self, change):
      return isinstance(change, dict) and 'new node' in change
#+END_SRC
  
#+BEGIN_SRC python
  def _queue_next_graph(self):
      change = self.queue.popleft()
      if self.isdelta(change):
          <<gui/test/vis/animated/modify graph>>
      else:
          self.set_graph(change)
#+END_SRC

#+BEGIN_SRC python :noweb-ref "gui/test/vis/animated/modify graph"
  node = change['new node'][0]
  data = change['new node'][1]
  for key, value in data.keys(), data.values():
      self.graph[node][key] = value
#+END_SRC

***** Drawing the Animation
:PROPERTIES:
:noweb-ref: gui/test/vis/animated/animating
:ID:       55D924C7-536E-4403-AC34-75FD637F18C5
:END:
Just as you test the quality of the brakes before the power of an
engine, we define a flag and setter for stopping the animation.
#+BEGIN_SRC python
  def stop(self):
      self.should_stop = True
#+END_SRC
  
By using the =Timer= class from the =threading= module, we daisy-chain
the painting of next graphs.  Since =_queue_next_graph= is a
relatively expensive step, we queue the next step to start before we
calculate the next graph.
#+BEGIN_SRC python
  def start(self):
      if not self.should_stop:
          self.paint(self.next_graph, do_layout=False)
          threading.Timer(self.interval, self.start, [self]).start()
          self._queue_next_graph()
#+END_SRC
Queueing the next frame before calculating it /does/ introduce a race
condition!  It is possible that the animator could skip a frame---or
worse, show a partially updated graph---if
- the interpreter is extraordinarily slow,
- there are many properties to each node in the graph, or
- the update interval is extremely short.
This arises because =next_graph= is altered in-place in
=_queue_next_graph= /during/ the countdown for the next frame.  If
this countdown finishes before =next_graph= is ready it will /still be
painted/, it just may be incorrect.

It would seem that this risk is inherent in multi-threading this
solution and the risk could be avoided by single-threading.  However,
this has other consequences that are unacceptable.  The na√Øve
single-threaded approach would look similar to the following:
#+BEGIN_SRC python :tangle nil :noweb-ref nil
  while not self.should_stop:
      self.paint(do_layout=False)
      self._queue_next_graph()
#+END_SRC
In this approach, there is no chance for =should_stop= to change and
the animation would continue /ad infinitum/ with no hope of a graceful
exit.
