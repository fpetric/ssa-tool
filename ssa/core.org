#+TITLE: Self-Stabilizing Algorithm
#+AUTHOR: Sean Allred
#+DATE: [2014-03-09 Sun]

#+PROPERTY: noweb tangle

* Overview
:PROPERTIES:
:ID:       62455C31-1F11-4259-B2F6-DE3E5AEA48A8
:END:
#+BEGIN_SRC python :tangle "core.py"
  <<imports>>
  <<program logic>>
  <<file io>>
#+END_SRC
* Core Logic
:PROPERTIES:
:noweb-ref: program logic
:END:
** Overview
:PROPERTIES:
:ID:       78B5126E-F0DB-4231-8BA0-B9D8BC3ED824
:END:
The =Algorithm= class is simply defined as a ruleset
#+BEGIN_SRC python
  class Algorithm:
      """A self-stabilizing algorithm

      <<documentation>>
      """
      #% algorithm %#
      def __init__(self, ruleset=None):
          self.ruleset = ruleset
          self.__getitem__ = self.ruleset.__getitem__
          self.predicates = lambda: list(self.ruleset.keys())
          self.moves = lambda: [m for m in p for p in self.ruleset.values()]
      #% end-algorithm %#

      #% algorithm-ruleset-assertions %#
      <<ruleset assertions>>
      #% end-algorithm-ruleset-assertions %#

      <<construction>>
      <<run>>
      <<stability>>
      <<saving>>
      <<miscellaneous>>
#+END_SRC
** Ensuring a Proper Data-Structure
:PROPERTIES:
:noweb-ref: ensure moveset is proper
:END:
We assume that =self.ruleset= is a dictionary structure that
correlates to the mathematical definition---something like the
following:
#+BEGIN_SRC python :tangle no :noweb-ref nil
  some_predicate = lambda n, N: True
  some_move = lambda n, N: n, N
  
  #% algorithm-ruleset-ex %#
  ruleset = {
      some_predicate: [some_move, some_move],
      some_predicate: [some_move, some_move, some_move],
      some_predicate: [some_move]
  }
  #% end-algorithm-ruleset-ex %#
#+END_SRC
We require that every key in the =moveset= be a callable object, as a
=Predicate= would be.  (Keeping in style with 'duck typing' dictates
that we only check for the behavior's existence.)

So, we first ensure that =moveset= is a mapping type.
#+BEGIN_SRC python
  assert hasattr(self.ruleset, '__getitem__')
#+END_SRC
Note: if we wanted to ensure it was also nonempty, we can add the
following line:
#+BEGIN_SRC python :tangle no :noweb-ref nil
  assert hasattr(self.ruleset, '__len__') and len(self.ruleset > 0)
#+END_SRC
We then ensure that every single 'key' is callable,
#+BEGIN_SRC python
  assert all(map(lambda p: hasattr(p, '__call__'),
                 self.ruleset))
#+END_SRC
and takes exactly two arguments.
#+BEGIN_SRC python
  assert all(map(lambda p: Algorithm.is_valid_function(p),
                 self.ruleset))
#+END_SRC

Now we must go through every value for each key to ensure that
- the value is a collection type
- every entry in the value is a callable function of two arguments
#+BEGIN_SRC python
  for predicate in self.ruleset:
      moves = self.ruleset[predicate]
      assert hasattr(moves, '__getitem__')
      assert all(map(lambda m: hasattr(m, '__call__') and
                               Algorithm.is_valid_function(m),
                     moves))
#+END_SRC
** Validating Functions
:PROPERTIES:
:noweb-ref: miscellaneous
:END:
To look at what the function needs, we load an introspection package.
#+BEGIN_SRC python :noweb-ref imports
  import inspect
#+END_SRC
#+BEGIN_SRC python :noweb-ref "ruleset assertions"
  def is_valid_function(function):
      return len(inspect.getargspec(function).args) is 2
#+END_SRC
#+BEGIN_SRC python
  @staticmethod
  def neighbor_data(graph, node):
      return {node: graph.node[node] for node in graph.neighbors(node)}
#+END_SRC
** Running the Algorithm
:PROPERTIES:
:noweb-ref: run
:END:
Since algorithms may take many iterations to converge, the following
function is provided in such a way so that it can take a number of
times to execute the algorithm.  This value defaults to 1.
#+BEGIN_SRC python
  #% daemon-run %#
  def run(self, graph, count=1):
      """Run the algorithm `count` times.
  
      <<run documentation>>
      """
      assert count >= 0
  
      history = list()
      while count > 0:
          <<run once>>
          count -= 1
      return history
  #% end-daemon-run %#
#+END_SRC
*** Running it Once
:PROPERTIES:
:noweb-ref: run once
:END:
We prepare a dictionary of privileged nodes that will store the
predicates each node satisfies as a list.  That is, if a node =n=
satisfies =p1=, =p2=, and =p3=, we know that
=privileged_nodes[n]=[p1, p2, p3]=.
#+BEGIN_SRC python
  privileged_nodes = dict()
#+END_SRC
To populate this data structure, we iterate through every node in our
graph, find its neighborhood, and then see if the node (with its
neighborhood) is privileged.  (Remember that privileges are functions
of a node and its neighborhood.)
#+BEGIN_SRC python
  #% daemon-find-privileged-nodes %#
  for node in graph:
      neighborhood = Algorithm.neighbor_data(graph, node)
      <<run is node privileged>>
  #% end-daemon-find-privileged-nodes %#
#+END_SRC
If there are no privileged nodes, break the loop.
#+BEGIN_SRC python
  if not privileged_nodes:
      break
#+END_SRC

Once we have this collection of all privileged nodes, we pick a random
node and get a random predicate that it satisfies.
#+BEGIN_SRC python
  #% daemon-pick-predicate %#
  node = random.choice(list(privileged_nodes.keys()))
  neighborhood = Algorithm.neighbor_data(graph, node)
  satisfied_predicate = random.choice(privileged_nodes[node])
  #% end-daemon-pick-predicate %#
#+END_SRC
Note that we now require the =random= module:
#+BEGIN_SRC python :noweb-ref imports
  import random
#+END_SRC

We then take our chosen predicate, access the moves that it implies,
and get a random one, calling it =next_move=.  We then use this move
on the node and its neighborhood to receive an updated node and
neighborhood.  (Note that, in practice, it will make more sense for
the function to simply update the node and neighborhood itself.)
#+BEGIN_SRC python
  #% daemon-apply-move %#
  old_node = copy.deepcopy(node)
  old_node_data = copy.deepcopy(graph.node[node])
  old_neighborhood = copy.deepcopy(neighborhood)

  next_move = random.choice(self.ruleset[satisfied_predicate])
  next_move(graph.node[node], neighborhood)
  #% end-daemon-apply-move %#
#+END_SRC
Note that we now require the =copy= module:
#+BEGIN_SRC python :noweb-ref imports
  import copy
#+END_SRC

Add this entire debacle to the history.
#+BEGIN_SRC python
  history.append({
      'chosen node': (old_node, old_node_data),
      'neighborhood of chosen node': old_neighborhood,
      'next move': next_move.__name__,
      'node after move': graph.node[node]
  })
#+END_SRC
***** TODO Can a move cause a node to write to its neighbors?
**** Is This Node Privileged?
:PROPERTIES:
:noweb-ref: run is node privileged
:END:
Run through all of the rules in our algorithm.  Since =ruleset= is a
dictionary, it will automatically iterate through the keys (and the
keys are =Predicate= values).  If the predicate is true for this node
and its neighborhood, at it to the dictionary (inserting a new value
if necessary).
#+BEGIN_SRC python
  #% daemon-get-privileges %#
  for predicate in self.ruleset:
      if predicate(graph.node[node], neighborhood.values()):
          if node in privileged_nodes:
              privileged_nodes[node] += predicate
          else:
              privileged_nodes[node] = [predicate]
  #% end-daemon-get-privileges %#
#+END_SRC
** Stability Analysis
:PROPERTIES:
:noweb-ref: stability
:END:
*** Determining if the Algorithm has Stabilized
#+BEGIN_SRC python
  def has_stabilized(self):
      """Returns True if the graph has stabilized.
  
      This function runs `Algorithm.run` twice."""
      pass
#+END_SRC
*** Running Until Stabilization
This is not recommended as there can be no guarantee of halt, but the
following is provided for completeness.
#+BEGIN_SRC python
  def stabilize(self, graph):
      while not self.has_stabilized():
          self.run(graph)
#+END_SRC
* File IO
:PROPERTIES:
:noweb-ref: file io
:END:
#+BEGIN_SRC python :noweb-ref imports
  import yaml
  import re
#+END_SRC
#+BEGIN_SRC python
  class Bundle:
      _unsanitary_function_name = re.compile(r'''[^A-Za-z_]''')

      def __init__(self, read=None, descriptor = 'bundle.yaml',
                                    move_dir   = 'moves',
                                    pred_dir   = 'predicates'):
          """Takes a path to a directory, potentially non-existent, and creates
          an SSAX-formatted bundle."""

          self.descriptor = descriptor
          self.move_dir = move_dir
          self.pred_dir = pred_dir

          self.algorithms = list()
          self.predicates = list()
          self.moves = list()

      def read(self, path, scope=globals()):
          def load_function(entity):
              ks = set(entity.keys())
              if 'predicate' in ks:
                  folder = self.pred_dir
                  name = entity['predicate']
              elif 'move' in ks:
                  folder = self.move_dir
                  name = entity['move']
              else:
                  raise Error('not predicate or move?? find a wizard')

              name = sanitize_function_name(name)
              with open('{}/{}/{}'.format(path, folder, entity['file'])) as f:
                  lines = f.readlines()
              lines = ['def {}(v, N):\n'.format(name)] + \
                      ['    '+l for l in lines]
              exec "".join(lines) in scope

              f = scope[name]
              f.__dict__.update(entity)

              if 'predicate' in ks:
                  self.predicates.append(f)
              elif 'move' in ks:
                  self.moves.append(f)
              else:
                  raise Error('''not predicate or move? no but seriously,
                                 how did this happen? find a wizard''')


          def sanitize_function_name(name):
              return self._unsanitary_function_name.sub('_', name)

          with open('{path}/{self.descriptor}'.format(path=path, self=self)) as f:
              bundle = yaml.load(f)

          algorithm_descriptions = []
          for entity in bundle:
              keyset = set(entity.keys())
              if 'predicate' in keyset or 'move' in keyset:
                  load_function(entity)
              elif 'algorithm' in keyset:
                  algorithm_descriptions.append(entity)
              else:
                  raise IOError('Error in bundle file {!s}.'.format(path),
                                'No entity matches {!r}.'.format(entity))

          for ad in algorithm_descriptions:
              rules = dict()
              for rule in ad['rules']:
                  pred = sanitize_function_name(rule['predicate'])
                  pred = scope[pred]
                  rules[pred] = list()
                  for move in rule['moves']:
                      move = sanitize_function_name(move)
                      move = scope[move]
                      rules[pred].append(move)
              alg = Algorithm(rules)
              alg.__dict__.update(ad)
              self.algorithms.append(alg)

      def add(self, entity, kind):
          ls = None
          if   kind == 'predicate': ls = self.predicates
          elif kind == 'move':      ls = self.moves
          elif kind == 'algorithm': ls = self.algorithms
          else: raise Error('Unknown entity.  Did you spell it right?')
              
      def write(self, path):
          lines = list()
          for entity in self.predicates + self.moves:
              lines.append(yaml.dump(entity.__dict__))

          for a in self.algorithms:
              temp = dict()
              temp 
#+END_SRC
