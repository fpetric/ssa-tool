#+TITLE: Generators
#+AUTHOR: Sean Allred
#+DATE: [2014-03-09 Sun]

#+PROPERTY: noweb tangle

* Overview
:PROPERTIES:
:ID:       0F11043C-3A3B-4307-B8FF-D2DD79A8B9EF
:END:
#+BEGIN_SRC python :tangle "generators.py"
  import networkx
  import random
  from itertools import combinations
  
  class BasicNode:
      def __init__(self):
          pass
      def __repr__(self):
          return '{}::{}'.format(id(self), self.__dict__)
  
  <<random graphs>>

  if __name__ == '__main__':
      import doctest
      doctest.testmod()
#+END_SRC
* Generating a Random Graph
:PROPERTIES:
:noweb-ref: random graphs
:ID:       C315D9D2-BE1C-447A-8961-4080AFD9B648
:END:
To thoroughly test graph algorithms (in lieu of or in preparation for
proof), it is very useful to have a means to create randomized graphs
with certain characteristics.  NetworkX has a few generators at its
disposal for creating graphs with deeper properties than I have
knowledge of, but the following function is able to create a random
graph with nodes having randomized properties.
#+BEGIN_SRC python
  def random_graph(degree, edge_probability=0.5, base_class=BasicNode, **properties):
      """Generates a random graph of `degree` nodes, a specified
      probability for edges, and a number of random properties.
      
      <<documentation>>
      """
      r = random.Random()
      G = networkx.Graph()

      <<check if degree is range>>
      <<check for dynamically-created generators>>
  
      for n in range(degree):
          <<add node>>
  
      <<add edges>>
      
      return G
#+END_SRC
** Documentation
:PROPERTIES:
:noweb-ref: documentation
:END:
#+BEGIN_SRC markdown
  <<summary>>
  <<basic usage>>
  <<errors>>
#+END_SRC
*** Summary
:PROPERTIES:
:noweb-ref: summary
:END:
#+BEGIN_SRC markdown
  If `degree` is a tuple, it is assumed to be a (min, max) tuple
  defining an inclusive range of possible degrees.
    
  Each `properties` value can be a function of a random number
  generator.  If the value does not have `__call__` defined, it will be
  assumed a string unless, as a string, it is one of the following:
    
  - 'int(n,m)' :: a random integer in [n, m]
  - 'float()'  :: a random floating point number in [0, 1)
  - 'bool(n)'  :: a random boolean with a probability of truth between 0
                  and 1 inclusive (where 1 is True).
    
  If the property value is neither callable nor a string of this form,
  then the value is simply set raw.
#+END_SRC
*** Basic Usage
    :PROPERTIES:
    :noweb-ref: doctest basic usage
    :END:
#+BEGIN_SRC markdown
  Pass in a single argument, the degree of the graph, to get the
  bare-minimum graph (with a certain edge probability):
    
      >>> G = random_graph(50)
      >>> len(G.nodes())
      50
  
  Pass in a tuple to get a range of values:
    
      >>> G = random_graph((40, 60))
      >>> len(G.nodes()) in range(40, 60 + 1)
      True
    
  You can also use a few intelligent arguments, such as bool(n):
  
      >>> G = random_graph(10, marked='bool(1)')
      >>> all(map(lambda n: G.node[n]['marked'], G.node))
      True
      >>> G = random_graph(10, marked='bool(0)')
      >>> any(map(lambda n: G.node[n]['marked'], G.node))
      False
    
  float():
  
      >>> G = random_graph(1000, weight='float()')
      >>> .45 < sum(map(lambda n: G.node[n]['weight'], G.node)) / 1000 < .55
      True
    
  and int(min, max):
    
      >>> G = random_graph(10, age='int(40, 50)')
      >>> all(map(lambda n: G.node[n]['age'] in range(40, 50 + 1), G.node))
      True
  
  For any attribute, you can specify a function or a generator.  You can
  even supply a function that *returns* a generator.  All functions must
  take exactly one required argument, a random number generator, as its
  first parameter.
  
  (ref:smp - optionify random thingy)
  
  Consider the following:
  
      >>> graph = random_graph(5, weight=(i for i in range(5)))
      >>> sorted([graph.node[n]['weight'] for n in graph.nodes()])
      [0, 1, 2, 3, 4]
  
                                                                           (ref:)
#+END_SRC

*** Possible Errors
:PROPERTIES:
:noweb-ref: doctest errors
:END:
#+BEGIN_SRC markdown
  Be careful about the arguments you pass.  If you want a range of
  possible values for the degree, ensure you pass an iterable of exactly
  two elements.
    
      >>> random_graph((1,2,3))
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      ValueError: Wrong number of values for (min, max) degree
    
  Mind the arguments for the keywords 'bool', 'int', and 'float'.
    
      >>> random_graph(5, marked='int(3,4,5)')
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      ValueError: Wrong number of arguments for int.
  
  If you are using generators, keep in mind that *each* node must be
  given a value.  If the generator produces less values than you give
  the graph nodes, an exception will be raised:
  
      >>> n = 5
      >>> g = random_graph(n + 1, weight=(i for i in range(n)))
      Traceback (most recent call last):
        File "<stdin>", line 1, in ?
      Exception: Ran out of iterations for the generator given by 'weight'
#+END_SRC
** Code
*** Check Degree
:PROPERTIES:
:noweb-ref: check if degree is range
:END:
#+BEGIN_SRC python
  if hasattr(degree, '__getitem__'):
      if len(degree) is not 2:
          raise ValueError('Wrong number of values for (min, max) degree')
      degree = r.randint(*degree)
#+END_SRC
*** Check for Dynamic Generators
:PROPERTIES:
:noweb-ref: check for dynamically-created generators
:END:
In playing with the tool for a while, I've come to see a few use cases
for the ability to create 'on the fly' generators with lambda
expressions.  The code currently checks for functions by checking if
they define =__call__=, and this is good behavior.  However, it is
possible that such a function could return a generator object, so we
need to run through each property /first/ to check if calling any
existing functions yields a generator (no pun intended).
#+BEGIN_SRC python
  for key in properties:                  
      if hasattr(properties[key], '__call__'):
          check_value = properties[key](r)
          if hasattr(check_value, '__next__'):
              properties[key] = check_value
#+END_SRC
*** Adding Nodes
:PROPERTIES:
:noweb-ref: add node
:END:
#+BEGIN_SRC python
  new_node = base_class()

  G.add_node(new_node)
      
  for key in properties:
      property_key = str(key)
      property_value = properties[key]
      
      <<check for property overwrite>>
      
      <<parse and set property value>>
#+END_SRC
**** Property Overwrite
:PROPERTIES:
:noweb-ref: check for property overwrite
:END:
#+BEGIN_SRC python
  # Avoid overwriting properties.  This could happen if the
  # user passes in something that is a dictionary rather
  # than a traditional KV list.  We'll accept anything that
  # has __str__, but __str__ is not meant to be unique.
  if hasattr(new_node, property_key): 
      raise Exception('Did not overwrite duplicate property')
#+END_SRC
**** Property Set
:PROPERTIES:
:noweb-ref: parse and set property value
:END:
The new value can be a couple things.  If it is a callable function
(implements =__call__=), we assume it is some function that expects a
=random.Random= object as its single required parameter.  If it is a
generator (implements =next=), we retrieve the next value.  Otherwise,
we parse =property_value= as a string
#+BEGIN_SRC python
  new_value = None
    
  if hasattr(property_value, '__call__'):
      new_value = property_value(r)
  elif hasattr(property_value, '__next__'):
      try:
          new_value = next(property_value)
      except StopIteration:
          raise Exception('Ran out of iterations for the generator given by {!r}'\
                              .format(property_key))
  elif '(' in property_value and ')' in property_value: # val is a func
      # collect the arguments
      # TODO: make this safe, i.e. destroy `eval`
      func = property_value[:property_value.index('(')]
      args = eval(property_value[property_value.index('('):])
      ex = lambda t: ValueError('Wrong number of arguments for {}.'.format(t))
      
      if func == 'float':
          if len(args) is not 0: raise ex('float')
          new_value = r.random()
      elif func == 'int':
          if len(args) is not 2: raise ex('int')
          new_value = r.randint(*args)
      elif func == 'bool':
          new_value = r.random() <= float(args)
  else:
      new_value = property_value
  
  G.node[new_node][property_key] = new_value
#+END_SRC
***** WISH_LIST Enhance security
We have the line =args=eval(property_value[...])=.  This should be
fine given the audience, but it is terribly unsafe.  Find a better way.

Perhaps we can represent arguments as tuples, LISP-style?
#+BEGIN_EXAMPLE
  random_graph(15,
    marked = ('bool', .3)
    weight = ('float',)
    ranged = ('float', 5, 7)
    more_r = ('range', 1, 10))
#+END_EXAMPLE
with =range= taking place of =int(...)=.
*** Adding Edges
:PROPERTIES:
:noweb-ref: add edges
:END:
#+BEGIN_SRC python
  for src, dst in combinations(G.nodes(), 2):
      # perhaps add switch to check for __call__(node_a, node_b)
      if r.random() <= edge_probability:
          G.add_edge(src, dst)
#+END_SRC

** Test
* Tests
** Random Graph Generation
:PROPERTIES:
:noweb-ref: random graph test
:ID:       CDB12492-67B2-47B6-9BC2-7963F8053617
:END:
This test is structured as those above, with a few specializations.
Since the random graph generator does not (and should not) create
predictable or reproducible results, we must create a very large
random graph (1000 nodes) and then perform some analysis on that same
graph multiple times.  (Otherwise, the tests would hang on this
portion for some time.)

We import all those classes that we need to and define a testing class
to contain the random graph in the correct scope.  After we define a
few helper functions to look at only one attribute at a time, we then
make our assertions on what the results /should/ look like.
#+BEGIN_SRC python :tangle "generator_tests.py"
  import unittest
  from nose.tools import *
  from ssa.simulation.generators import random_graph

  class RandomGraphTest(unittest.TestCase):
      @classmethod
      def setupClass(cls):
          cls.G = \
          <<create random graph>>
  
      <<define helper functions>>
  
      <<test randomness>>

      <<test functions and generators>>
#+END_SRC

*** Creating the Graph
:PROPERTIES:
:noweb-ref: create random graph
:ID:       6E674337-9BFF-4C4A-92A6-D991C5A6B4AE
:END:
We create a random graph with the following properties:
- degree :: 1000
- edge probability :: 70%
- marked :: 30% chance of being marked
- answer :: equal chances of being 'yes', 'no', or 'maybe'
- weight :: a random real in [0, 1)
- age :: a random number between 18 and 65
#+BEGIN_SRC python
  random_graph(\
      1000, .7,
      marked='bool(.3)',
      answer=lambda r: r.choice(['yes', 'no', 'maybe']),
      weight='float()',
      age='int(18, 65)')
#+END_SRC
*** Define Helper Functions
:PROPERTIES:
:noweb-ref: define helper functions
:ID:       4B714A8D-79AD-4B78-BF03-834351064EE1
:END:
Now that we have a graph of a bunch of objects with randomized
attributes, we need a way to extract these attributes out of the
entire collection of nodes in the graph.  We define
=get_attribute(attr)= to construct a list of values:
#+BEGIN_LaTeX
  \[
    \{\text{$n$.attribute} : n \in G\}
  \]
#+END_LaTeX
and an averaging function to average numerical values:
#+BEGIN_LaTeX
  \[
  \frac{1}{|G|}\sum_{n \in G}{\text{$n$.attribute}}
  \]
#+END_LaTeX
#+BEGIN_SRC python
  def get_attribute(self, attr):
      return list(map(lambda n: self.G.node[n][attr], self.G.node))
  
  def avg(self, attr):
      return float(sum(self.get_attribute(attr)))/len(self.G.nodes())
#+END_SRC
*** Testing Randomness
:PROPERTIES:
:noweb-ref: test randomness
:ID:       E80C466D-A580-4B4F-926D-C0F084E34436
:END:
We are ready to implement our tests.  For =bool=, =float=, and =int=,
we test to make sure the average values we collect from the generated
graph match the theoretical averages (the ones we gave to target). For
the special =func= case, we do something a little fancier.

To test the =func= case, we count the occurances of each possible
=answer= and find its absolute variance from the theoretical value it
should have ($1000/3=333.\bar3$).  We then sum those variances and
ensure it is less than some (generous) threshold value.
#+BEGIN_SRC python
  def test_bool(self):
      assert_almost_equal(self.avg('marked'), .3, 1)
    
  def test_float(self):
      assert_almost_equal(self.avg('weight'), .5, 1)
    
  def test_int(self):
      g = self.avg('age')
      e = (18.0 + 65)/2
    
      assert_almost_equal(g/100, e/100, 1)
    
  def test_func(self):
      g = sum([abs(self.get_attribute('answer').count(c) - 333.33) / 1000.0
               for c in ['yes', 'no', 'maybe']])
    
      assert_less(g, .1)
#+END_SRC
*** Testing Functions and Generators
:PROPERTIES:
:noweb-ref: test functions and generators
:ID:       D70CB956-AB21-4120-A4DF-368C0DDA70EE
:END:
The functions and generators are where the real generality (to an
extent) comes in.  We should be able to define a function that takes
one argument---a random number generator---and spits out values for
us.  In fact, we should be able to use a few things:
- a function that, given a random number generator, returns a value
- a function that, given a random number generator, returns a
  generator of values
- a raw generator of values.

#+BEGIN_SRC python
  def test_raw_func(self):
      choices = ['yes', 'no', 'maybe']
      def get_marked(random_instance):
          return random_instance.choice(choices)
      g = random_graph(15, marked=get_marked)
      assert all(map(lambda n: g.node[n]['marked'] in choices, g.node))
  
  def test_lambda_func(self):
      choices = ['yes', 'no', 'maybe']
      g = random_graph(15, marked=lambda r: r.choice(choices))
      assert all(map(lambda n: g.node[n]['marked'] in choices, g.node))
#+END_SRC
and now to test generators:
#+BEGIN_SRC python
  def test_generator_func(self):
      def gen_weight(random_instance):
          while True:
              yield random_instance.random()
      g = random_graph(15, weight=gen_weight)
      assert all(map(lambda n: 0 <= g.node[n]['weight'] < 1, g.node))
  
  def test_generator_func2(self):
      def gen_in_range(minimum, maximum):
          # iter(int, True) is an infinite generator: 0, 0, 0, ...
          return lambda r: (r.uniform(minimum, maximum)
                            for i in iter(int, True))
  
      g = random_graph(15, weight=gen_in_range(10, 20))
      assert all(map(lambda n: 10 <= g.node[n]['weight'] <= 20, g.node))
#+END_SRC
