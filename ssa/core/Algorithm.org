look at function annotations

have the decorators do the whole copy constructor thing so that
side-effects are not a thing.  this will make =history= work.
#+TITLE: Self-Stabilizing Algorithm
#+AUTHOR: Sean Allred
#+DATE: [2014-03-09 Sun]

#+PROPERTY: noweb tangle

* Overview
:PROPERTIES:
:ID:       78B5126E-F0DB-4231-8BA0-B9D8BC3ED824
:END:
The =Algorithm= class is simply defined as a ruleset
#+BEGIN_SRC python :tangle "Algorithm.py" :noweb tangle
  <<imports>>
  import random
  import copy

  <<documentation parsing>>
  <<predicates and moves>>
  
  class Algorithm:
      """A self-stabilizing algorithm
  
      <<documentation>>
      """
      #% algorithm %#
      def __init__(self, ruleset=None):
          self.ruleset = ruleset
      #% end-algorithm %#
  
      #% algorithm-ruleset-assertions %#
      <<ruleset assertions>>
      #% end-algorithm-ruleset-assertions %#
  
      <<construction>>
      <<run>>
      <<stability>>
      <<read and write>>
      <<miscellaneous>>
#+END_SRC
* Documentation Parsing
:PROPERTIES:
:noweb-ref: documentation parsing
:END:
#+BEGIN_SRC python
  def parsedoc(symbol):
      """Parses documentation
  
      <<parsedoc documentation>>
      """
      if not symbol.__doc__ or symbol.__doc__.strip() == '':
          return dict()
      try:
          doc_lines = [s.strip() for s in symbol.__doc__.split('\n')]
          idx = doc_lines.index('')
  
          name = '\n'.join(doc_lines[:idx])
          newidx = doc_lines.index('',idx+1)
  
          tex = '\n'.join(doc_lines[idx+1:newidx])
          human = '\n'.join(doc_lines[newidx+1:])
      except:
          print(locals())
          raise None
  
      return { 'name':       name.strip(),
               'doc tex':     tex.strip(),
               'doc human': human.strip()
           }
#+END_SRC
** Online Documentation
:PROPERTIES:
:noweb-ref: parsedoc documentation
:END:
#+BEGIN_SRC markdown
  `parsedoc` parses the docstring of a symbol into three parts:
  
  - short name
  - TeXnical documentation
  - Long-form documentation
  
  Each part must be seperated by two blank lines (whitespace is
  ignored).
  
      >>> def hello(a, b):
      ...     '''Name
      ... 
      ...     TeXnical documentation
      ... 
      ...     Human documentation
      ...     '''
      ...     return b
      >>> parsedoc(hello)['name']
      'Name'
      >>> parsedoc(hello)['doc tex']
      'TeXnical documentation'
      >>> parsedoc(hello)['doc human']
      'Human documentation'
#+END_SRC
* Predicates and Moves
:PROPERTIES:
:noweb-ref: predicates and moves
:END:
** Metadata
:PROPERTIES:
:noweb-ref: define metadata
:END:
#+BEGIN_SRC python
  #% define-metadata %#
  func.meta = {
      'author':  author,
      'version': version
  }
  func.meta.update(parsedoc(func))
  func.meta.update(others)
  #% end-define-metadata %#
#+END_SRC
** Predicates
Predicates and moves are simply functions that have associated
meta-data.  Since this meta-data is sort of 'extra' on top of what a
self-stabilizing algorithm /needs/ to be, predicates and moves are
distinguished by Python /decorators/.
#+BEGIN_SRC python
  #% predicate %#
  def predicate(author, version, **others):
      """Marks a function as a predicate, providing metadata.
  
      <<predicate documentation>>
      """
      def _predicate(func):
          <<define metadata>>
          return func
      return _predicate
  #% end-predicate %#
#+END_SRC
*** Online Documentation
:PROPERTIES:
:noweb-ref: predicate documentation
:END:
#+BEGIN_SRC markdown
  Consider an example:
  
      >>> @predicate(author  = 'Sean Allred',
      ...            version = '1.0',
      ...            custom_key = 'foo')
      ... def all_neighbors_marked(this_node, neighbors):
      ...     <<predicate documentation example function>>
  
  This will set various meta-data in a member dictionary called `meta`:
  
      >>> all_neighbors_marked.meta['author']
      'Sean Allred'
      >>> all_neighbors_marked.meta['version']
      '1.0'
      >>> all_neighbors_marked.meta['custom_key']
      'foo'
#+END_SRC
**** Function Definition
:PROPERTIES:
:noweb-ref: predicate documentation example function
:END:
#+BEGIN_SRC python
  '''all neighbors are marked
    
  `forall u in N(v) "marked"(u) = 0
    
  Each node in the neighborhood of the current
  node is unmarked.
  '''
  
  for u in neighbors:
      if u['marked']:
          return False
  return True
#+END_SRC
** Move
#+BEGIN_SRC python
  #% move %#
  def move(author, version, **others):
      """Marks a function as a move, providing metadata.
  
      <<move documentation>>
      """
      def _move(func):
          <<define metadata>>
          return func
      return _move
  #% end-move %#
#+END_SRC
*** Online Documentation
:PROPERTIES:
:noweb-ref: move documentation
:END:
#+BEGIN_SRC markdown
  Consider an example:
  
      >>> @move(author = 'Sean Allred',
      ...      version = '1.0',
      ...   custom_key = 'foo')
      ... def mark_this_node(this_node, neighbors):
      ...     <<move documentation example function>>
  
  This will set various meta-data in a member dictionary called `meta`:
  
      >>> mark_this_node.meta['author']
      'Sean Allred'
      >>> mark_this_node.meta['version']
      '1.0'
      >>> mark_this_node.meta['custom_key']
      'foo'
#+END_SRC
**** Function Definition
:PROPERTIES:
:noweb-ref: move documentation example function
:END:
#+BEGIN_SRC python
  '''mark this node
    
  "marked"(n) = 1
    
  Mark this node.
  '''
  
  u['marked'] = True
#+END_SRC

* Ensuring a Proper Data-Structure
:PROPERTIES:
:noweb-ref: ensure moveset is proper
:END:
We assume that =self.ruleset= is a dictionary structure that
correlates to the mathematical definition---something like the
following:
#+BEGIN_SRC python :tangle no :noweb-ref nil
  some_predicate = lambda n, N: True
  some_move = lambda n, N: n, N
  
  #% algorithm-ruleset-ex %#
  ruleset = {
      some_predicate: [some_move, some_move],
      some_predicate: [some_move, some_move, some_move],
      some_predicate: [some_move]
  }
  #% end-algorithm-ruleset-ex %#
#+END_SRC
We require that every key in the =moveset= be a callable object, as a
=Predicate= would be.  (Keeping in style with 'duck typing' dictates
that we only check for the behavior's existence.)

So, we first ensure that =moveset= is a mapping type.
#+BEGIN_SRC python
  assert hasattr(self.ruleset, '__getitem__')
#+END_SRC
Note: if we wanted to ensure it was also nonempty, we can add the
following line:
#+BEGIN_SRC python :tangle no :noweb-ref nil
  assert hasattr(self.ruleset, '__len__') and len(self.ruleset > 0)
#+END_SRC
We then ensure that every single 'key' is callable,
#+BEGIN_SRC python
  assert all(map(lambda p: hasattr(p, '__call__'),
                 self.ruleset))
#+END_SRC
and takes exactly two arguments.
#+BEGIN_SRC python
  assert all(map(lambda p: Algorithm.is_valid_function(p),
                 self.ruleset))
#+END_SRC

Now we must go through every value for each key to ensure that
- the value is a collection type
- every entry in the value is a callable function of two arguments
#+BEGIN_SRC python
  for predicate in self.ruleset:
      moves = self.ruleset[predicate]
      assert hasattr(moves, '__getitem__')
      assert all(map(lambda m: hasattr(m, '__call__') and
                               Algorithm.is_valid_function(m),
                     moves))
#+END_SRC
* Validating Functions
:PROPERTIES:
:noweb-ref: miscellaneous
:END:
To look at what the function needs, we load an introspection package.
#+BEGIN_SRC python :noweb-ref "imports"
  import inspect
#+END_SRC
#+BEGIN_SRC python :noweb-ref "ruleset assertions"
  def is_valid_function(function):
      return len(inspect.getargspec(function).args) is 2
#+END_SRC
#+BEGIN_SRC python
  @staticmethod
  def neighbor_data(graph, node):
      return {node: graph.node[node] for node in graph.neighbors(node)}
#+END_SRC
* Running the Algorithm
:PROPERTIES:
:noweb-ref: run
:END:
Since algorithms may take many iterations to converge, the following
function is provided in such a way so that it can take a number of
times to execute the algorithm.  This value defaults to 1.
#+BEGIN_SRC python
  #% daemon-run %#
  def run(self, graph, count=1):
      """Run the algorithm `count` times.
  
      <<run documentation>>
      """
      assert count >= 0
  
      history = list()
      while count > 0:
          <<run once>>
          count -= 1
      return history
  #% end-daemon-run %#
#+END_SRC
** Running it Once
:PROPERTIES:
:noweb-ref: run once
:END:
We prepare a dictionary of privileged nodes that will store the
predicates each node satisfies as a list.  That is, if a node =n=
satisfies =p1=, =p2=, and =p3=, we know that
=privileged_nodes[n]=[p1, p2, p3]=.
#+BEGIN_SRC python
  privileged_nodes = dict()
#+END_SRC
To populate this data structure, we iterate through every node in our
graph, find its neighborhood, and then see if the node (with its
neighborhood) is privileged.  (Remember that privileges are functions
of a node and its neighborhood.)
#+BEGIN_SRC python
  #% daemon-find-privileged-nodes %#
  for node in graph:
      neighborhood = Algorithm.neighbor_data(graph, node)
      <<run is node privileged>>
  #% end-daemon-find-privileged-nodes %#
#+END_SRC
If there are no privileged nodes, break the loop.
#+BEGIN_SRC python
  if not privileged_nodes:
      break
#+END_SRC

Once we have this collection of all privileged nodes, we pick a random
node and get a random predicate that it satisfies.
#+BEGIN_SRC python
  #% daemon-pick-predicate %#
  node = random.choice(list(privileged_nodes.keys()))
  neighborhood = Algorithm.neighbor_data(graph, node)
  satisfied_predicate = random.choice(privileged_nodes[node])
  #% end-daemon-pick-predicate %#
#+END_SRC
We then take our chosen predicate, access the moves that it implies,
and get a random one, calling it =next_move=.  We then use this move
on the node and its neighborhood to receive an updated node and
neighborhood.  (Note that, in practice, it will make more sense for
the function to simply update the node and neighborhood itself.)
#+BEGIN_SRC python
  #% daemon-apply-move %#
  old_node = copy.deepcopy(node)
  old_node_data = copy.deepcopy(graph.node[node])
  old_neighborhood = copy.deepcopy(neighborhood)

  next_move = random.choice(self.ruleset[satisfied_predicate])
  next_move(graph.node[node], neighborhood)
  #% end-daemon-apply-move %#
#+END_SRC
Add this entire debacle to the history.
#+BEGIN_SRC python
  history.append({
      'chosen node': (old_node, old_node_data),
      'neighborhood of chosen node': old_neighborhood,
      'next move': next_move.__name__,
      'node after move': graph.node[node]
  })
#+END_SRC
**** TODO Can a move cause a node to write to its neighbors?
*** Is This Node Privileged?
:PROPERTIES:
:noweb-ref: run is node privileged
:END:
Run through all of the rules in our algorithm.  Since =ruleset= is a
dictionary, it will automatically iterate through the keys (and the
keys are =Predicate= values).  If the predicate is true for this node
and its neighborhood, at it to the dictionary (inserting a new value
if necessary).
#+BEGIN_SRC python
  #% daemon-get-privileges %#
  for predicate in self.ruleset:
      if predicate(graph.node[node], neighborhood.values()):
          if node in privileged_nodes:
              privileged_nodes[node] += predicate
          else:
              privileged_nodes[node] = [predicate]
  #% end-daemon-get-privileges %#
#+END_SRC
* Stability Analysis
** Determining if the Algorithm has Stabilized
:PROPERTIES:
:noweb-ref: stability
:END:
#+BEGIN_SRC python
  def has_stabilized(self):
      """Returns True if the graph has stabilized.
  
      This function runs `Algorithm.run` twice."""
      pass
#+END_SRC
** Running Until Stabilization
This is not recommended as there can be no guarantee of halt, but the
following is provided for completeness.
#+BEGIN_SRC python
  def stabilize(self, graph):
      while not self.has_stabilized():
          self.run(graph)
#+END_SRC
* Saving
:PROPERTIES:
:ID:       D097345A-0ECA-4635-9700-8CC0C7CFB1F0
:noweb-ref: read and write
:END:
#+BEGIN_SRC yaml :tangle ind-set.yaml :padline no :noweb-ref nil
  #%BUNDLE 1.0
  - algorithm: Independent Set
    author: Sean Allred
    date: 2014-05-17
    rules:
      - file: marked-and-neighbor-marked.py
        author: Sean Allred
        version: 1.0
        doc:
          name: Node should unmark
          tex: "'marked'(n) = 1 `land `exists v `in N(n) : 'marked'(n) = 1"
          description: Returns True if the node is marked when a neighbor is also marked.
        moves:
          - file: unmark.py
            doc:
              name: Unmark this node
              tex: "'marked'(n) = 0"
      - file: unmarked-and-neighbor-unmarked.py
        author: Sean Allred
        version: 1.0
        doc:
          name: Node should mark
          tex: "'marked'(n) = 0 `land `forall v `in N(n), 'marked'(v) = 0"
          description: Returns True is the node is unmarked when none of its neighbors are marked.
        moves:
          - file: mark.py
            doc:
              name: Mark this node
              tex: "'marked'(n) = 1"
#+END_SRC
** Reading Saves
:PROPERTIES:
:noweb-ref: read and write
:END:
This is honestly the coolest sh*t I've done with Python /to date/.
We define a static method =Algorithm.read_bundle= that takes the path to any =ssax=-structured directory.
(See the paper.apdxA for details.)

Called as =algorithms = Algorithm.read_bundle('ind-set.yaml')=.
#+BEGIN_SRC python
  @staticmethod
  def read_bundle(path, descriptor='bundle.yaml'):
      import yaml
      with open('{}/{}'.format(path, descriptor), 'r') as f:
          bundle = yaml.load(f)

      <<sanitize function names>>
      <<define logic to load a function>>
      <<parse bundle descriptor>>
      <<assemble algorithms>>
      
      return algorithms
#+END_SRC
*** Sanitizing Function Names
:PROPERTIES:
:noweb-ref: sanitize function names
:END:
#+BEGIN_SRC python
  import re
  unsanitary_name = re.compile(r'''[^A-Za-z_]''')
  def sanitize_function_name(name):
      return unsanitary_name.sub('_', name)
#+END_SRC
*** Function Load Logic
:PROPERTIES:
:noweb-ref: define logic to load a function
:END:
#+BEGIN_SRC python
  def load_function(name, folder, filename):
      name = sanitize_function_name(name)

      with open('{}/{}/{}'.format(path, folder, filename)) as f:
          lines = f.readlines()
      lines = ['def {}(v, N):\n'.format(name)] + ['    '+l for l in lines]

      exec("".join(lines)) in globals()
#+END_SRC
*** Parsing the Descriptor
:PROPERTIES:
:noweb-ref: parse bundle descriptor
:END:
#+BEGIN_SRC python
  algorithm_descriptions = []
  for entity in bundle:
      keyset = set(entity.keys())
      if 'predicate' in keyset:
          load_function(entity['predicate'], 'predicates', entity['file'])
      elif 'move' in keyset:
          load_function(entity['move'], 'moves', entity['file'])
      elif 'algorithm' in keyset:
          algorithm_descriptions.append(entity)
      else:
          raise IOError('Error in bundle file {!s}.'.format(path),
                        'No entity matches {!r}.'.format(entity))
#+END_SRC
*** Algorithm Assembly
:PROPERTIES:
:noweb-ref: assemble algorithms
:END:
#+BEGIN_SRC python
  algorithms = list()
  for alg_descr in algorithm_descriptions:
      rules = dict()
      for rule in alg_descr['rules']:
          pred = rule['predicate']
          rules[pred] = list()
          for move in rule['moves']:
              move = sanitize_function_name(move)
              rules[pred].append(globals()[move])
      algorithms.append(Algorithm(rules))
#+END_SRC
** Writing Saves
#+BEGIN_SRC python
  def write_yaml(self, path):
      pass
#+END_SRC
* Tests
:PROPERTIES:
:ID:       07052652-FE3B-43BC-B448-5A5478626532
:END:
#+BEGIN_SRC python :tangle "Algorithm.py"
  if __name__ == "__main__":
      import doctest
      doctest.testmod()
#+END_SRC
#+BEGIN_SRC python :noweb-ref "test imports"
  import sys
  sys.path.append('/Users/sean/github/vermiculus/smppaper/ssa-tool')
  
  import unittest
  from nose.tools import *
  from ssa.core.Algorithm import Algorithm
  from ssa.core.Algorithm import predicate
  from ssa.core.Algorithm import move
#+END_SRC
#+BEGIN_SRC python :tangle "Algorithm_test.py"
  <<test imports>>

  class AlgorithmTest(unittest.TestCase):
      @classmethod
      def setupClass(cls):
          cls.graphs = list()
          <<create random graphs>>
          
          cls.algorithm = dict()
          <<create test algorithms>>
  
      def test_metadata(self):
          pred = list(self.algorithm['independent set'].ruleset.keys())[0]
          assert pred.meta['name']      != ''
          assert pred.meta['doc tex']   != ''
          assert pred.meta['doc human'] != ''
#+END_SRC
** Creating a Few Random Graphs
:PROPERTIES:
:noweb-ref: create random graphs
:END:
Using the generators module, we can create a few random graphs quite easily.
#+BEGIN_SRC python :noweb-ref "test imports"
  from ssa.simulation.generators import random_graph
  import random
#+END_SRC
#+BEGIN_SRC python
  for i in range(10):
      cls.graphs.append(
          random_graph(random.randint(50, 200), random.random(),
                       marked='bool(.3)',
                       answer=lambda r: r.choice(['yes', 'no', 'maybe']),
                       weight='float()',
                       age='int(18, 65)'))
#+END_SRC
** ALL OF THE ALGORITHMS
:PROPERTIES:
:noweb-ref: create test algorithms
:END:
#+BEGIN_SRC python
  <<independent set>>
#+END_SRC
*** Independent Set
:PROPERTIES:
:noweb-ref: independent set
:END:
#+BEGIN_SRC python
  <<ind-set declare predicates>>
  <<ind-set declare moves>>
  
  cls.algorithm['independent set'] = \
  Algorithm({
       node_should_mark: [mark_node],
     node_should_unmark: [unmark_node]
  })
#+END_SRC
**** Predicates
:PROPERTIES:
:noweb-ref: ind-set declare predicates
:END:
#+BEGIN_SRC python
  #% example-predicate %#
  @predicate(author='Sean Allred', version='1.0')
  def node_should_unmark(node, neighborhood):
      """Rule 1
  
      "marked"(n) = 1 `land `exists v `in N(n) : "marked"(v) = 1
  
      Returns True if the node is marked where a neighbor is also
      marked.
      """
      is_marked = n['marked']
      neighbor_marked = any(map(lambda v: v['marked'],
                                neighborhood))
      return is_marked and neighbor_marked
  #% end-example-predicate %#
  
  @predicate(author='Sean Allred', version='1.0')
  def node_should_mark(node, neighborhood):
      """Rule 2
  
      "marked"(n) = 0 `land `forall v `in N(n), "marked"(v) = 0
  
      Returns True if the node is not marked and its entire neighborhood
      is also unmarked.
      """
      marked = n['marked']
      neighbor_marked = any(map(lambda v: v['marked'],
                                neighborhood))
      return not (marked or neighbor_marked)
#+END_SRC
**** Moves
:PROPERTIES:
:noweb-ref: ind-set declare moves
:END:
#+BEGIN_SRC python
  #% example-move %#
  @move(author='Sean Allred', version='1.0')
  def mark_node(node, neighborhood):
      node['marked'] = True
      return node, neighborhood
  #% end-example-move %#
  
  @move(author='Sean Allred', version='1.0')
  def unmark_node(node, neighborhood):
      node['marked'] = False
      return node, neighborhood
#+END_SRC
